import{_ as n,c as a,a as i,o as e}from"./app-Dmwo-0Oh.js";const l={};function p(r,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h1 id="基础篇-numpy-下-深度学习中的常用操作" tabindex="-1"><a class="header-anchor" href="#基础篇-numpy-下-深度学习中的常用操作"><span>基础篇 NumPy（下）深度学习中的常用操作</span></a></h1><p>通过上节课的学习，我们已经对 NumPy 数组有了一定的了解，正所谓实践出真知，今天我们就以一个图像分类的项目为例，看看 NumPy 的在实际项目中都有哪些重要功能。</p><p>我们先从一个常见的工作场景出发，互联网教育推荐平台，每天都有千万量级的文字与图片的广告信息流入。为了给用户提供更加精准的推荐，你的老板交代你设计一个模型，让你把包含各个平台 Logo（比如包含极客时间 Logo）的图片自动找出来。</p><p><img src="https://static001.geekbang.org/resource/image/1e/5d/1ecb3ccdd0b408b0350e255f7e0c875d.png?wh=318x116" alt="图片"></p><p>想要解决这个图片分类问题，我们可以分解成数据加载、训练与模型评估三部分（其实基本所有深度学习的项目都可以这样划分）。其中数据加载跟模型评估中，就经常会用到 NumPy 数组的相关操作。</p><p>那么我们先来看看数据的加载。</p><h2 id="数据加载阶段" tabindex="-1"><a class="header-anchor" href="#数据加载阶段"><span>数据加载阶段</span></a></h2><p>这个阶段我们要做的就是把训练数据读进来，然后给模型训练使用。训练数据不外乎这三种：图片、文本以及类似二维表那样的结构化数据。</p><p>不管使用 PyTorch 还是 TensorFlow，或者是传统机器学习的 scikit-learn，我们在读入数据这一块，都会先把数据转换成 NumPy 的数组，然后再进行后续的一系列操作。</p><p>对应到我们这个项目中，需要做的就是把训练集中的图片读入进来。对于图片的处理，我们一般会使用 Pillow 与 OpenCV 这两个模块。</p><p>虽然 Pillow 和 OpenCV 功能看上去都差不多，但还是有区别的。在 PyTorch 中，很多图片的操作都是基于 Pillow 的，所以当使用 PyTorch 编程出现问题，或者要思考、解决一些图片相关问题时，要从 Pillow 的角度出发。</p><p>下面我们先以单张图片为例，将极客时间的那张 Logo 图片分别用 Pillow 与 OpenCV 读入，然后转换为 NumPy 的数组。</p><h3 id="pillow-方式" tabindex="-1"><a class="header-anchor" href="#pillow-方式"><span>Pillow 方式</span></a></h3><p>首先，我们需要使用 Pillow 中的下述代码读入上面的图片。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">from PIL import Image</span>
<span class="line">im = Image.open(&#39;jk.jpg&#39;)</span>
<span class="line">im.size</span>
<span class="line">输出: 318, 116</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Pillow 是以二进制形式读入保存的，那怎么转为 NumPy 格式呢？这个并不难，我们只需要利用 NumPy 的 asarray 方法，就可以将 Pillow 的数据转换为 NumPy 的数组格式。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">import numpy as np</span>
<span class="line"></span>
<span class="line">im_pillow = np.asarray(im)</span>
<span class="line"></span>
<span class="line">im_pillow.shape</span>
<span class="line">输出：(116, 318, 3)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="opencv-方式" tabindex="-1"><a class="header-anchor" href="#opencv-方式"><span>OpenCV 方式：</span></a></h3><p>OpenCV 的话，不再需要我们手动转格式，它直接读入图片后，就是以 NumPy 数组的形式来保存数据的，如下面的代码所示。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">import cv2</span>
<span class="line">im_cv2 = cv2.imread(&#39;jk.jpg&#39;)</span>
<span class="line">type(im_cv2)</span>
<span class="line">输出：numpy.ndarray</span>
<span class="line"></span>
<span class="line">im_cv2.shape</span>
<span class="line">输出：(116, 318, 3)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合代码输出可以发现，我们读入后的数组的最后一个维度是 3，这是因为图片的格式是 RGB 格式，表示有 R、G、B 三个通道。对于计算视觉任务来说，绝大多数处理的图片都是 RGB 格式，如果不是 RGB 格式的话，要记得事先转换成 RGB 格式。 这里有个地方需要你关注，Pillow 读入后通道的顺序就是 R、G、B，而 OpenCV 读入后顺序是<strong>B、G、R</strong>。</p><p>模型训练时的通道顺序需与预测的通道顺序要保持一致。也就是说使用 Pillow 训练，使用 OpenCV 读入图片直接进行预测的话，不会报错，但结果会不正确，所以大家一定要注意。</p><p>接下来，我们就验证一下 Pillow 与 OpenCV 读入数据通道的顺序是否如此，借此引出有关 Numpy 数组索引与切片、合并等常见问题。</p><p>怎么验证这条结论呢？只需要将 R、G、B 三个通道的数据单独提取出来，然后令另外两个通道的数据全为 0 即可。</p><p>这里我给你说说为什么这样做。RGB 色彩模式是工业界的一种颜色标准，RGB 分别代表红、绿、蓝三个通道的颜色，将这三种颜色混合在一起，就形成了我们眼睛所能看到的所有颜色。</p><p>RGB 三个通道各有 256 个亮度，分别用数字 0 到 255 表示，数字越高代表亮度越强，数字 0 则是代表最弱的亮度。在我们的例子中，如果一个通道的数据再加另外两个全 0 的通道（相当于关闭另外两个通道），最终图像以红色格调（可以先看一下后文中的最终输出结果）呈现出来的话，我们就可以认为该通道的数据是来源于 R 通道，G 与 B 通道的证明同样可以如此。</p><p>好，首先我们提取出 RGB 三个通道的数据，这可以从数组的索引与切片说起。</p><h3 id="索引与切片" tabindex="-1"><a class="header-anchor" href="#索引与切片"><span>索引与切片</span></a></h3><p>如果你了解 Python，那么索引和切片的概念你应该不陌生。</p><p>就像图书目录里的索引，我们可以根据索引标注的页码快速找到需要的内容，而 Python</p><p>里的索引也是同样的功能，它用来定位数组中的某一个值。而切片意思就相当于提取图书中从某一页到某一页的内容。</p><p>NumPy 数组的索引方式与 Python 的列表的索引方式相同，也同样支持切片索引。</p><p>这里需要你注意的是在 NumPy 数组中经常会出现用冒号来检索数据的形式，如下所示：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow[:, :, 0]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是什么意思呢？我们一起来看看。“：”代表全部选中的意思。我们的图片读入后，会以下图的状态保存在数组中。</p><p><img src="https://static001.geekbang.org/resource/image/20/01/20ayy454079771245f44f983b2130e01.jpg?wh=1920x1391" alt=""></p><p>上述代码的含义就是取第三个维度索引为 0 的全部数据，换句话说就是，取图片第 0 个通道的所有数据。</p><p>这样的话，通过下面的代码，我们就可以获得每个通道的数据了。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow_c1 = im_pillow[:, :, 0]</span>
<span class="line">im_pillow_c2 = im_pillow[:, :, 1]</span>
<span class="line">im_pillow_c3 = im_pillow[:, :, 2]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获得了每个通道的数据，接下来就需要生成一个全 0 数组，该数组要与 im_pillow 具有相同的宽高。</p><p>全 0 数组你还记得怎么生成吗？可以自己先思考一下，生成的代码如下所示。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">zeros = np.zeros((im_pillow.shape[0], im_pillow.shape[1], 1))</span>
<span class="line">zeros.shape</span>
<span class="line">输出：(116, 318, 1)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们只需要将全 0 的数组与 im_pillow_c1、im_pillow_c2、im_pillow_c3 进行拼接，就可以获得对应通道的图像数据了。</p><h3 id="数组的拼接" tabindex="-1"><a class="header-anchor" href="#数组的拼接"><span>数组的拼接</span></a></h3><p>刚才我们拿到了单独通道的数据，接下来就需要把一个分离出来的数据跟一个全 0 数组拼接起来。如下图所示，红色的可以看作单通道数据，白色的为全 0 数据。</p><p><img src="https://static001.geekbang.org/resource/image/ee/c1/eedf20bf55a6c0521309d7c102719bc1.jpg?wh=1920x899" alt="图片"></p><p>NumPy 数组为我们提供了 np.concatenate((a1, a2, ...), axis=0)方法进行数组拼接。其中，a1，a2, ...就是我们要合并的数组；axis 是我们要沿着哪一个维度进行合并，默认是沿着 0 轴方向。</p><p>对于我们的问题，是要沿着 2 轴的方向进行合并，也是我们最终的目标是要获得下面的三幅图像。 <img src="https://static001.geekbang.org/resource/image/68/7e/68bcd8107bf71ef876a339350a10c77e.jpg?wh=1603x653" alt=""></p><p>那么，我们先将 im_pillow_c1 与全 0 数组进行合并，生成上图中最左侧的数组，有了图像的数组才能获得最终图像。合并的代码跟输出结果如下：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow_c1_3ch = np.concatenate((im_pillow_c1, zeros, zeros),axis=2)</span>
<span class="line">---------------------------------------------------------------------------</span>
<span class="line">AxisError                                 Traceback (most recent call last)</span>
<span class="line">&lt;ipython-input-21-e3d53c33c94d&gt; in &lt;module&gt;</span>
<span class="line">----&gt; 1 im_pillow_c1_3ch = np.concatenate((im_pillow_c1, zeros, zeros),axis=2)</span>
<span class="line">&lt;__array_function__ internals&gt; in concatenate(*args, **kwargs)</span>
<span class="line">AxisError: axis 2 is out of bounds for array of dimension 2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里你可能很惊讶，竟然报错了？错误的原因是在 2 维数组中，axis 如果等于 2 的话会越界。</p><p>我们看看 im_pillow_c1 与 zeros 的形状。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow_c1.shape</span>
<span class="line">输出：(116, 318)</span>
<span class="line">zeros.shape</span>
<span class="line">输出：(116, 318, 1)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原来是我们要合并的两个数组维度不一样啊。那么如何统一维度呢？将 im_pillow_c1 变成(116, 318, 1)即可。</p><h4 id="方法一-使用-np-newaxis" tabindex="-1"><a class="header-anchor" href="#方法一-使用-np-newaxis"><span>方法一：使用 np.newaxis</span></a></h4><p>我们可以使用 np.newaxis 让数组增加一个维度，使用方式如下。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow_c1 = im_pillow_c1[:, :, np.newaxis]</span>
<span class="line">im_pillow_c1.shape</span>
<span class="line">输出：(116, 318, 1)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上面的代码，就可以将 2 个维度的数组转换为 3 个维度的数组了。 这个操作在你看深度学习相关代码的时候经常会看到，只不过 PyTorch 中的函数名 unsqueeze(), TensorFlow 的话是与 NumPy 有相同的名字，直接使用 tf.newaxis 就可以了。</p><p>然后我们再次将 im_pillow_c1 与 zeros 进行合并，这时就不会报错了，代码如下所示：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow_c1_3ch = np.concatenate((im_pillow_c1, zeros, zeros),axis=2)</span>
<span class="line">im_pillow_c1_3ch.shape</span>
<span class="line">输出：(116, 318, 3)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="方法二-直接赋值" tabindex="-1"><a class="header-anchor" href="#方法二-直接赋值"><span>方法二：直接赋值</span></a></h4><p>增加维度的第二个方法就是直接赋值，其实我们完全可以生成一个与 im_pillow 形状完全一样的全 0 数组，然后将每个通道的数值赋值为 im_pillow_c1、im_pillow_c2 与 im_pillow_c3 就可以了。我们用这种方式生成上图中的中间与右边图像的数组。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow_c2_3ch = np.zeros(im_pillow.shape)</span>
<span class="line">im_pillow_c2_3ch[:,:,1] = im_pillow_c2</span>
<span class="line"></span>
<span class="line">im_pillow_c3_3ch = np.zeros(im_pillow.shape)</span>
<span class="line">im_pillow_c3_3ch[:,:,2] = im_pillow_c3</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的话，我们就可以将三个通道的 RGB 图片打印出来了。 关于绘图，你可以使用 matplotlib 进行绘图，它是 NumPy 的绘图库。如果你需要绘图，可以在<a href="https://matplotlib.org/stable/gallery/index.html" target="_blank" rel="noopener noreferrer">这个网站</a>上找到各种各样的例子，然后根据它提供的代码进行修改，具体如何绘图我就不展开了。</p><p>说回我们的通道顺序验证问题，完成前面的操作后，你可以用下面的代码将原图、R 通道、G 通道与 B 通道的 4 幅图打印出来，你看是不是 RGB 顺序的呢？</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">from matplotlib import pyplot as plt</span>
<span class="line">plt.subplot(2, 2, 1)</span>
<span class="line">plt.title(&#39;Origin Image&#39;)</span>
<span class="line">plt.imshow(im_pillow)</span>
<span class="line">plt.axis(&#39;off&#39;)</span>
<span class="line">plt.subplot(2, 2, 2)</span>
<span class="line">plt.title(&#39;Red Channel&#39;)</span>
<span class="line">plt.imshow(im_pillow_c1_3ch.astype(np.uint8))</span>
<span class="line">plt.axis(&#39;off&#39;)</span>
<span class="line">plt.subplot(2, 2, 3)</span>
<span class="line">plt.title(&#39;Green Channel&#39;)</span>
<span class="line">plt.imshow(im_pillow_c2_3ch.astype(np.uint8))</span>
<span class="line">plt.axis(&#39;off&#39;)</span>
<span class="line">plt.subplot(2, 2, 4)</span>
<span class="line">plt.title(&#39;Blue Channel&#39;)</span>
<span class="line">plt.imshow(im_pillow_c3_3ch.astype(np.uint8))</span>
<span class="line">plt.axis(&#39;off&#39;)</span>
<span class="line">plt.savefig(&#39;./rgb_pillow.png&#39;, dpi=150)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://static001.geekbang.org/resource/image/12/10/1264b5c889bfyy5e0d00668cfa205110.png?wh=900x600" alt="图片"></p><h3 id="深拷贝-副本-与浅拷贝-视图" tabindex="-1"><a class="header-anchor" href="#深拷贝-副本-与浅拷贝-视图"><span>深拷贝（副本）与浅拷贝（视图）</span></a></h3><p>刚才我们通过获取图片通道数据的练习，不过操作确实比较繁琐，介绍这些方法也主要是为了让你掌握切片索引和数组拼接的知识点。</p><p>其实我们还有一种更加简单的方式获得三个通道的 BGR 数据，只需要将图片读入后，直接将其中的两个通道赋值为 0 即可。代码如下所示：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">from PIL import Image</span>
<span class="line">import numpy as np</span>
<span class="line"></span>
<span class="line">im = Image.open(&#39;jk.jpg&#39;)</span>
<span class="line">im_pillow = np.asarray(im)</span>
<span class="line">im_pillow[:,:,1:]=0</span>
<span class="line">输出：</span>
<span class="line">---------------------------------------------------------------------------</span>
<span class="line">ValueError                                Traceback (most recent call last)</span>
<span class="line">&lt;ipython-input-146-789bda58f667&gt; in &lt;module&gt;</span>
<span class="line">      4 im = Image.open(&#39;jk.jpg&#39;)</span>
<span class="line">      5 im_pillow = np.asarray(im)</span>
<span class="line">----&gt; 6 im_pillow[:,:,1:-1]=0</span>
<span class="line">ValueError: assignment destination is read-only</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行刚才的代码，报错提示说数组是只读数组，没办法进行修改。那怎么办呢？我们可以使用 copy 来复制一个数组。 说到 copy()的话，就要说到浅拷贝与深拷贝的概念，[上节课]我们说到创建数组时就提过，np.array()属于深拷贝，np.asarray()则是浅拷贝。</p><p>简单来说，浅拷贝或称视图，指的是与原数组共享<strong>数据</strong>的数组，请注意，只是数据，没有说共享形状。视图我们通常使用 view()来创建。常见的切片操作也会返回对原数组的浅拷贝。</p><p>请看下面的代码，数组 a 与 b 的数据是相同的，形状确实不同，但是修改 b 中的数据后，a 的数据同样会发生变化。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">a = np.arange(6)</span>
<span class="line">print(a.shape)</span>
<span class="line">输出：(6,)</span>
<span class="line">print(a)</span>
<span class="line">输出：[0 1 2 3 4 5]</span>
<span class="line"></span>
<span class="line">b = a.view()</span>
<span class="line">print(b.shape)</span>
<span class="line">输出：(6,)</span>
<span class="line">b.shape = 2, 3</span>
<span class="line">print(b)</span>
<span class="line">输出：[[0 1 2]</span>
<span class="line"> [3 4 5]]</span>
<span class="line">b[0,0] = 111</span>
<span class="line">print(a)</span>
<span class="line">输出：[111   1   2   3   4   5]</span>
<span class="line">print(b)</span>
<span class="line">输出：[[111   1   2]</span>
<span class="line"> [  3   4   5]]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而深拷贝又称副本，也就是完全复制原有数组，创建一个新的数组，修改新的数组不会影响原数组。深拷贝使用 copy()方法。</p><p>所以，我们将刚才报错的程序修改成下面的形式就可以了。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">im_pillow = np.array(im)</span>
<span class="line">im_pillow[:,:,1:]=0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可别小看深拷贝和浅拷贝的区别。这里讲一个我以前遇到的坑吧，我曾经要开发一个部署在手机端的人像分割模型。</p><p>为了提高模型的分割效果，我考虑了新的实验方法——将前一帧的数据也作为当前帧的输入进行考虑，训练阶段没有发生问题，但是在调试阶段发现模型的效果非常差。</p><p>后来经过研究，我才发现了问题的原因。原因是我为了可视化分割效果，我将前一帧的数据进行变换打印出来。同时，我错误的采用了浅拷贝的方式，将前一帧的数据传入当前帧，所以说传入到当前帧的数据是经过变化的，而不是原始的输出。</p><p>这时再传入当前帧，自然无法得到正确结果。当时因为这个坑，差点产生要放弃这个实验的想法，后面改成深拷贝才解决了问题。</p><p>好了，讲到这里，你是否可以用上述的方法对 OpenCV 读取图片读入通道顺序进行一下验证呢？</p><h2 id="模型评估" tabindex="-1"><a class="header-anchor" href="#模型评估"><span>模型评估</span></a></h2><p>在模型评估时，我们一般会将模型的输出转换为对应的标签。</p><p>假设现在我们的问题是将图片分为 2 个类别，包含极客时间的图片与不包含的图片。模型会输出形状为(2, )的数组，我们把它叫做 probs，它存储了两个概率，我们假设索引为 0 的概率是包含极客时间图片的概率，另一个是其它图片的概率，它们两个概率的和为 1。如果极客时间对应的概率大，则可以推断该图片为包含极客时间的图片，否则为其他图片。</p><p>简单的做法就是判断 probs[0]是否大于 0.5，如果大于 0.5，则可以认为图片是我们要寻找的。</p><p>这种方法固然可以，但是如果我们需要判断图片的类别有很多很多种呢？</p><p>例如，有 1000 个类别的 ImageNet。也许你会想到遍历这个数组，求出最大值对应的索引。</p><p>那如果老板让你找出概率最大的前 5 个类别呢？有没有更简单点的方法？我们继续往下看。</p><h3 id="argmax-vs-argmin-求最大-最小值对应的索引" tabindex="-1"><a class="header-anchor" href="#argmax-vs-argmin-求最大-最小值对应的索引"><span>Argmax Vs Argmin：求最大/最小值对应的索引</span></a></h3><p>NumPy 的 argmax(a, axis=None)方法可以为我们解决求最大值索引的问题。如果不指定 axis，则将数组默认为 1 维。</p><p>对于我们的问题，使用下述代码即可获得拥有最大概率值的图片。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">np.argmax(probs)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Argmin 的用法跟 Argmax 差不多，不过它的作用是获得具有最小值的索引。</p><h3 id="argsort-数组排序后返回原数组的索引" tabindex="-1"><a class="header-anchor" href="#argsort-数组排序后返回原数组的索引"><span>Argsort：数组排序后返回原数组的索引</span></a></h3><p>那现在我们再把问题升级一下，比如需要你将图片分成 10 个类别，要找到具有最大概率的前三个类别。</p><p>模型输出的概率如下：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">probs = np.array([0.075, 0.15, 0.075, 0.15, 0.0, 0.05, 0.05, 0.2, 0.25])</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这时，我们就可以借助 argsort(a, axis=-1, kind=None)函数来解决该问题。np.argsort 的作用是对原数组进行从小到大的排序，返回的是对应元素在原数组中的索引。 np.argsort 包括后面这几个关键参数：</p><ul><li>a 是要进行排序的原数组；</li><li>axis 是要沿着哪一个轴进行排序，默认是-1，也就是最后一个轴；</li><li>kind 是采用什么算法进行排序，默认是快速排序，还有其他排序算法，具体你可以看看数据结构的排序算法。</li></ul><p>我们还是结合例子来理解，你可以看看下面的代码，它描述了我们使用 argsort 对 probs 进行排序，然后返回对应坐标的全过程。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">probs_idx_sort = np.argsort(-probs)  #注意，加了负号，是按降序排序</span>
<span class="line">probs_idx_sort</span>
<span class="line">输出：array([8, 7, 1, 3, 0, 2, 5, 6, 4])</span>
<span class="line">#概率最大的前三个值的坐标</span>
<span class="line">probs_idx_sort[:3]</span>
<span class="line">输出：array([8, 7, 1])</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>恭喜你，完成了这一节课的学习。这一节介绍了一些常用且重要的功能。几乎在所有深度学习相关的项目中，你都会常常用到这些函数，当你阅读别人的代码的时候也会经常看到。</p><p>让我们一起来复习一下今天学到的这些函数，我画了一张表格，给你总结了它们各自的关键功能和使用要点。</p><p><img src="https://static001.geekbang.org/resource/image/29/yd/296b503a7c2fb89987695035c0184yyd.jpg?wh=1709x798" alt=""></p><p>我觉得 NumPy 最难懂的还是上节课的轴，如果你把轴的概念理解清楚之后，理解今天的内容会更加轻松。理解了原理之后，关键还是动手练习。</p><h2 id="每课一练" tabindex="-1"><a class="header-anchor" href="#每课一练"><span>每课一练</span></a></h2><p>给定数组 scores，形状为（256，256，2），scores[: , :, 0] 与 scores[:, :, 1]对应位置元素的和为 1，现在我们要根据 scores 生产数组 mask，要求 scores 通道 0 的值如果大于通道 1 的值，则 mask 对应的位置为 0，否则为 1。</p><p>scores 如下，你可以试试用代码实现：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">scores = np.random.rand(256, 256, 2)</span>
<span class="line">scores[:,:,1] = 1 - scores[:,:,0]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>欢迎你在留言区记录你的疑问或者收获，也推荐你把这节课分享给你的朋友。</p>`,113)]))}const c=n(l,[["render",p]]),t=JSON.parse('{"path":"/3.tech/83.PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/03_%E5%9F%BA%E7%A1%80%E7%AF%87-NumPy%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html","title":"基础篇 NumPy（下）深度学习中的常用操作","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"数据加载阶段","slug":"数据加载阶段","link":"#数据加载阶段","children":[{"level":3,"title":"Pillow 方式","slug":"pillow-方式","link":"#pillow-方式","children":[]},{"level":3,"title":"OpenCV 方式：","slug":"opencv-方式","link":"#opencv-方式","children":[]},{"level":3,"title":"索引与切片","slug":"索引与切片","link":"#索引与切片","children":[]},{"level":3,"title":"数组的拼接","slug":"数组的拼接","link":"#数组的拼接","children":[]},{"level":3,"title":"深拷贝（副本）与浅拷贝（视图）","slug":"深拷贝-副本-与浅拷贝-视图","link":"#深拷贝-副本-与浅拷贝-视图","children":[]}]},{"level":2,"title":"模型评估","slug":"模型评估","link":"#模型评估","children":[{"level":3,"title":"Argmax Vs Argmin：求最大/最小值对应的索引","slug":"argmax-vs-argmin-求最大-最小值对应的索引","link":"#argmax-vs-argmin-求最大-最小值对应的索引","children":[]},{"level":3,"title":"Argsort：数组排序后返回原数组的索引","slug":"argsort-数组排序后返回原数组的索引","link":"#argsort-数组排序后返回原数组的索引","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]},{"level":2,"title":"每课一练","slug":"每课一练","link":"#每课一练","children":[]}],"git":{"updatedTime":1746672966000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":2,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"873191059aa4709eddd6184a409223b5054edb2a","time":1746672966000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: pytorch fixed"},{"hash":"b44b80ec6b8c2ebffa55c7b2b54259609c76baed","time":1745668690000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"add pytorch course"}]},"filePathRelative":"3.tech/83.PyTorch深度学习实战/03_基础篇-NumPy（下）：深度学习中的常用操作.md"}');export{c as comp,t as data};
