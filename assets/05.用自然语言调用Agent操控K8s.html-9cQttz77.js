import{_ as s,c as a,b as e,o as p}from"./app-C01vnHKY.js";const t={};function l(i,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="用自然语言调用-agent-操控-k8s" tabindex="-1"><a class="header-anchor" href="#用自然语言调用-agent-操控-k8s"><span>用自然语言调用 Agent 操控 K8s</span></a></h1><p>看似复杂的 Agent 实际上只是将人类的工作经验传授给大模型，使其能够代替我们完成任务，理解起来并不困难。更为简单的是，在实际操作中，我们只需要设计出一套优质的 prompt 模板，就能完成 Agent 应用开发的一半工作，真是应了那句话：得 prompt 者得天下！</p><h2 id="传统的-kubernetes-交互方式" tabindex="-1"><a class="header-anchor" href="#传统的-kubernetes-交互方式"><span>传统的 Kubernetes 交互方式</span></a></h2><p>众所周知，与 Kubernetes 交互的方式主要有以下几种：</p><ul><li><strong>kubectl 命令行</strong></li></ul><p>Kubectl 是官方提供的命令行工具，用于与 Kubernetes 集群进行交互。比如要获取 default 命名空间下的 Pods 信息，命令如下：</p><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell"><pre><code><span class="line">root@hi-test:~<span class="token comment"># kubectl get po</span></span>
<span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span>
<span class="line">ng-test-7bdff759b9-r49jj   1/1     Running   0          13d</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式是用户最常使用的。</p><ul><li><strong>SDK</strong></li></ul><p>Kubernetes 官方还提供了客户端 SDK，让程序员可以通过编程接口与 Kubernetes 交互。由于 Kubernetes 是用 Go 语言编写的，因此最流行的 SDK 是 client-go。以下是通过 client-go 列出 default 命名空间下 Pods 的示例代码：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">package</span> main</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token string">&quot;context&quot;</span></span>
<span class="line">    <span class="token string">&quot;fmt&quot;</span></span>
<span class="line">    <span class="token string">&quot;log&quot;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">    corev1 <span class="token string">&quot;k8s.io/api/core/v1&quot;</span></span>
<span class="line">    metav1 <span class="token string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span>
<span class="line">    <span class="token string">&quot;k8s.io/client-go/kubernetes&quot;</span></span>
<span class="line">    <span class="token string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 加载kubeconfig文件以获取客户端配置</span></span>
<span class="line">    config<span class="token punctuation">,</span> err <span class="token operator">:=</span> clientcmd<span class="token punctuation">.</span><span class="token function">BuildConfigFromFlags</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/root/.kube/config&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 创建Kubernetes客户端</span></span>
<span class="line">    clientset<span class="token punctuation">,</span> err <span class="token operator">:=</span> kubernetes<span class="token punctuation">.</span><span class="token function">NewForConfig</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 列出default命名空间下的Pods</span></span>
<span class="line">    pods<span class="token punctuation">,</span> err <span class="token operator">:=</span> clientset<span class="token punctuation">.</span><span class="token function">CoreV1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Pods</span><span class="token punctuation">(</span><span class="token string">&quot;default&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">List</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metav1<span class="token punctuation">.</span>ListOptions<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 遍历并打印Pod信息</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> pod <span class="token operator">:=</span> <span class="token keyword">range</span> pods<span class="token punctuation">.</span>Items <span class="token punctuation">{</span></span>
<span class="line">        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;Namespace: %v, Name: %v\\n&quot;</span><span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Name<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">Namespace: default, Nmae: ng-test-7bdff759b9-r49jj</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>GUI</strong></li></ul><p>如果觉得命令行不够直观，用户还可以使用 Kubernetes 官方的 Dashboard 或类似 Kuboard 这样的图形化界面进行操作。如下图展示了 Kuboard 中一个 Deployment 资源的操作页面。</p><p><img src="https://static001.geekbang.org/resource/image/f4/4c/f429afdd320af0037dc6a3c5abcb7f4c.png?wh=1920x797" alt="图片"></p><p>这种方式实现的原理相对简单，主要是基于前后端分离的架构设计，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/0a/3a/0a0fa4c9e76f397cb519a4ecf2c3703a.jpg?wh=1920x292" alt="图片"></p><p>前端 GUI 通过预设的 REST API 与后端服务器交互，后端服务器再通过 client-go 访问 Kubernetes，最终将结果返回前端展示在 GUI 上。</p><p>无论使用哪种方式，核心都是通过访问 Kubernetes 的 API server 来实现的。举个例子，我们可以用 curl 命令直接与 Kubernetes API 交互：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line">curl <span class="token operator">-</span>k <span class="token operator">-</span>H <span class="token string">&quot;Authorization: Bearer xxxxxxxxxxxxxxxxxx&quot;</span> \\</span>
<span class="line"><span class="token operator">&gt;</span>      https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">&lt;</span>your k8s server ip<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token operator">&lt;</span>your k8s server port<span class="token operator">&gt;</span><span class="token operator">/</span>api<span class="token operator">/</span>v1<span class="token operator">/</span>namespaces<span class="token operator">/</span><span class="token keyword">default</span><span class="token operator">/</span>pods</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该命令返回的结果如下（由于篇幅原因，省略部分输出）：</p><p><img src="https://static001.geekbang.org/resource/image/4e/84/4e2c246fe7e2f3edc3d297e5abe85384.png?wh=610x508" alt="图片"></p><p>Kubernetes 自引入国内已有 10 年之久，从最早只需掌握基本操作，到如今要求熟悉源码，技术要求日益提高。而上面提到的这些交互方式，已经成了程序员的基本功。作为技术从业者，紧跟时代变革至关重要。在 AI 时代，我们可以利用更加智能的方式与 Kubernetes 进行交互。</p><h2 id="用自然语言操控-kubernetes-原理与设计" tabindex="-1"><a class="header-anchor" href="#用自然语言操控-kubernetes-原理与设计"><span>用自然语言操控  Kubernetes  原理与设计</span></a></h2><p>在上一章，我们学习了 Function Calling 和 AI Agent，了解到大模型不仅能够选择合适的工具，还可以利用执行结果进行推理。本章将介绍如何用自然语言控制 Kubernetes。其原理并不复杂，只需将 kubectl 命令或通过 client-go 开发的函数封装成工具，供 Agent 选择执行即可，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/ba/b3/ba30da253eebdd58f77762cc9216dcb3.jpg?wh=1623x900" alt="图片"></p><p>接下来我们深入讨论如何使用自然语言操控 Kubernetes 的设计实现。从架构到细节，这将涉及 Cobra 命令行工具、API 设计、Prompt 模板、优化大模型输出以及合规性验证等多个方面。下面将为你介绍如何通过这些技术构建一个智能化的 Kubernetes 交互系统。</p><h3 id="cobra-命令行工具" tabindex="-1"><a class="header-anchor" href="#cobra-命令行工具"><span>Cobra 命令行工具</span></a></h3><p>对于后端程序员来说，命令行是最熟悉不过的了，它可以让我们在没有前端的时候，也可以做测试或者发布独立应用。</p><p>那用什么方式编写命令行应用呢？既然是云原生课程，那就可以模仿 kubectl 这套优秀的命令行工具。通过阅读 kubectl 源码，我们可以得知，其使用的是 Cobra 库。</p><p><img src="https://static001.geekbang.org/resource/image/0d/2f/0db95d31a026f0981c8425769d36642f.png?wh=1261x349" alt="图片"></p><p>实际上，Cobra 不仅 kubectl 在用，像是比较出名的包管理工具 Helm 等等也在使用，其已经成为了 Go 语言编写命令行工具的最佳实践。</p><h3 id="api-设计" tabindex="-1"><a class="header-anchor" href="#api-设计"><span>API 设计</span></a></h3><p>在开篇词中，我提到过，在 AI 时代，API 将成为一等公民。在 GUI 时代，对于 K8s 资源管理系统，API 是前端网页客户端访问后端 HTTP Server 的工具。而在 AI 时代，API 将会是 Agent 操作 K8s 的工具。之前聚合在一起为前端服务的 API 将会被打散，形成 “AI 微服务”的应用模式。因此我会以 Go 的 Gin 框架为例，一节课让你快速掌握 HTTP Server 开发。</p><h3 id="client-go-进阶用法" tabindex="-1"><a class="header-anchor" href="#client-go-进阶用法"><span>client-go 进阶用法</span></a></h3><p>常规的用 client-go 增删改查资源，可能许多从事云原生研发的同学都会。例如用 clientSet 获取 Kubernetes 标准资源，用动态客户端获取 CRD 资源等等。但是在本场景中，用户的需求是不确定的，比如用户说：“我要获取 default 命名空间下的 pod 列表”或者“请帮我删除 default 命名空间下的名字叫 foo 的 service”。我们无法预判用户要操作什么 Kubernetes 资源。</p><p>因此对于增删改操作，比较好的方法是利用 restMapper 获取到用户待操作资源的 GVR 后，用动态客户端来进行操作，这样可以实现通用化。而对于查操作，用 restMapper 当然也很方便。但如果每一次都通过访问 apiserver 在 Kubernetes 集群拿资源的话，一方面是会对 apiserver 造成流量压力，另一方面是速度会比较慢，因此业界的另一种做法是通过 Informer 机制，将资源缓存到本地，之后的查询全都在缓存中获取。而 Informer 还带有 Watch 机制，可以监听 Add、Delete、Update 事件，实时更新缓存内容。</p><p>我们会在后面两节课中，对这两种方式都做一下讲解，便于你在实际业务中根据需要自由选择合适的方法。</p><h3 id="多集群管理" tabindex="-1"><a class="header-anchor" href="#多集群管理"><span>多集群管理</span></a></h3><p>云原生发展到 2024 年，应该同学们都或多或少的听过或了解云边端多云混合管理这类概念。企业不仅需要管理不同的云环境，还要考虑边缘计算节点和本地基础设施的协同，确保数据流、应用部署和资源调度的高效性与一致性。这种跨云、跨地域、跨平台的管理需求对云原生架构提出了更高的挑战，同时也带来了新的机遇。</p><p>在这样的背景下，Karmada 作为一个开源的多集群管理工具，应运而生。Karmada 允许用户在多个 Kubernetes 集群之间实现资源的统一管理与调度，同时提供了高可用性和跨云环境的支持。它不仅帮助企业简化了多集群管理的复杂性，还可以优化资源的使用，提升系统的弹性和可靠性。</p><p>我们也会在用自然语言操控 Kubernetes 的项目中介绍和应用该工具。</p><h3 id="prompt-设计" tabindex="-1"><a class="header-anchor" href="#prompt-设计"><span>Prompt 设计</span></a></h3><p>操控 Kubernetes 资源的增删改查中，创建（增）是最为复杂的环节。因为我们需要大模型根据需求生成 Kubernetes 资源 YAML 文件，来用于安装部署。然而，大模型生成的 YAML 文件是否符合要求，往往需要进一步验证和优化。为此，我们可以通过精心设计和调整 prompt 来规范生成内容，确保最终输出的 YAML 文件能够直接用于安装和操作。</p><p>如果我直接对通义千问大模型这样说：“我要创建一个 k8s pod 镜像名称是 nginx”。效果是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/3b/67/3b035e794d32e2b5a95bef777af06d67.png?wh=1182x546" alt="图片"></p><p>如图所示，大模型会在 YAML 之前，给出一段文字。我们先不讨论 YAML 内容是否正确以及是否满足我们的要求，仅 YAML 前的这段文字，就需要我们用代码去做数据清洗（删除），非常不便。</p><p>因此，我们可以通过优化 prompt 来让大模型仅输出 YAML。prompt 如下：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">SYSTEM</span>
<span class="line">您是一名虚拟 k8s（Kubernetes）助手，可以根据用户输入生成 k8s yaml。yaml 保证能被 kubectl apply 命令执行。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">#Guidelines</span>
<span class="line">- 不做任何解释，只输出命令行或 yaml 内容。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">HUMAN</span>
<span class="line">用户输入: {user_input}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再次通过通义千问测试：</p><p><img src="https://static001.geekbang.org/resource/image/10/d0/10047d05b741bd30504a434a798256d0.png?wh=1218x612" alt="图片"></p><p>可以看到这一次，通义千问直接给出了 YAML。</p><p>我们在实际业务开发中，其实还可以给出更多的约束规则，来确保大模型生成的 YAML 符合业务需求。例如：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">#key point</span>
<span class="line">- 必须为 pod 设置名称和端口，如 80。</span>
<span class="line">- pod 必须有资源，其中必须设置限制和请求。如果未指定，则设置为 512M。</span>
<span class="line">- 必须根据业务系统设置 pod 名称。例如，订单系统的 pod 名称为 order-pod。如果未指定，默认名称为 unkown-pod。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再来测试一次：</p><p><img src="https://static001.geekbang.org/resource/image/e4/57/e43f5a0bfdb09c486dd463a266094357.png?wh=1237x645" alt="图片"></p><p>可以看到，这一次的 YAML 完全是按照我们的要求来的。在实际业务中，这部分规则，我们既可以预先填充，也可以结合 RAG 等知识库，让大模型来帮我们填充。总之，这些规则是可定制的。</p><h3 id="验证用户输入是否符合-kubernetes-资源要求" tabindex="-1"><a class="header-anchor" href="#验证用户输入是否符合-kubernetes-资源要求"><span>验证用户输入是否符合 Kubernetes 资源要求</span></a></h3><p>实际上，在上一步生成 YAML 模板之前，我们还需要做一些验证工作，用于验证用户输入的 prompt 是否是在创建一个正确的资源。例如用户输入：“我要创建一个 k8s hello，镜像是 nginx”，很显然，在 K8s 中，没有一个资源叫 hello，因此需要 Agent 在这一步调用工具做验证。</p><p>那验证方式，其实也很简单，我们只需要通过验证 kind 是否是在当前集群的资源列表中即可。为何要强调当前集群，因为除了 K8s 内置资源外，还有自定义资源 CRD。</p><h3 id="人类工具" tabindex="-1"><a class="header-anchor" href="#人类工具"><span>人类工具</span></a></h3><p>“删库跑路”是 IT 圈的著名黑话，我们都懂其意思。因此当我们做删除资源操作时，是否放心真的交给 Agent 去做，而不再最后确认一遍呢？肯定是不放心的。因此 LangChain 社区开发了一款特殊的工具 HumanTool。即当 Agent 判断某些危险操作需要人类确认时，会调用该工具来寻求人类帮助。我们会在后面的课程中，用 Go 语言复刻一下，试试效果如何。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本节课我带你回顾了几种传统的和 Kubernetes 交互的方式，并解析了其中的原理。那么，在 AI 时代，与时俱进的我们必然要掌握用自然语言“命令行”来操控 Kubernetes，实际上这样的方式也在业界被称作 LUI（语言用户界面，Language User Interface）。</p><p>从原理上看，用自然语言操控 Kubernetes 并不复杂，就是借助 Agent 推理和调用工具的能力，来根据用户请求调用相应的工具，完成与 Kubernetes 的交互。但实际上，Agent 只是一个 Copilot，主体业务逻辑还需要我们来思考完善。</p><p>这节课，我提到了 kubectl 插件的设计，prompt 模板设计与资源验证，client-go 处理通用资源的方法设计以及人类工具等等，都会在后面的课程中详细介绍。</p><p>在生产上，对 Kubernetes 的操作是严肃的，我们只有不断完善业务逻辑和工具细节，才能真正放心的将如此重任交给 AI。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>除了课程中列出的这些设计点，你还能想到哪些点子，能够提升我们这个软件的可用性和安全性吗？</p>`,70)]))}const o=s(t,[["render",l]]),r=JSON.parse('{"path":"/3.tech/84.AIAgent/05.%E7%94%A8%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8Agent%E6%93%8D%E6%8E%A7K8s.html","title":"用自然语言调用 Agent 操控 K8s","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"传统的 Kubernetes 交互方式","slug":"传统的-kubernetes-交互方式","link":"#传统的-kubernetes-交互方式","children":[]},{"level":2,"title":"用自然语言操控  Kubernetes  原理与设计","slug":"用自然语言操控-kubernetes-原理与设计","link":"#用自然语言操控-kubernetes-原理与设计","children":[{"level":3,"title":"Cobra 命令行工具","slug":"cobra-命令行工具","link":"#cobra-命令行工具","children":[]},{"level":3,"title":"API 设计","slug":"api-设计","link":"#api-设计","children":[]},{"level":3,"title":"client-go 进阶用法","slug":"client-go-进阶用法","link":"#client-go-进阶用法","children":[]},{"level":3,"title":"多集群管理","slug":"多集群管理","link":"#多集群管理","children":[]},{"level":3,"title":"Prompt 设计","slug":"prompt-设计","link":"#prompt-设计","children":[]},{"level":3,"title":"验证用户输入是否符合 Kubernetes 资源要求","slug":"验证用户输入是否符合-kubernetes-资源要求","link":"#验证用户输入是否符合-kubernetes-资源要求","children":[]},{"level":3,"title":"人类工具","slug":"人类工具","link":"#人类工具","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"思考题","slug":"思考题","link":"#思考题","children":[]}],"git":{"updatedTime":1749262836000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":1,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"0e82c49946907ddefcb6ccb279dc6debbb8ca726","time":1749262836000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"add 20250607"}]},"filePathRelative":"3.tech/84.AIAgent/05.用自然语言调用Agent操控K8s.md"}');export{o as comp,r as data};
