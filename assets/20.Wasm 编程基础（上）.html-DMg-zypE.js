import{_ as s,c as a,a as p,o as e}from"./app-Dmwo-0Oh.js";const t={};function i(l,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="wasm-编程基础-上" tabindex="-1"><a class="header-anchor" href="#wasm-编程基础-上"><span>Wasm 编程基础（上）</span></a></h1><p>在上节课，我从理论的角度，为你讲解了 Wasm 相关的一些知识，包括 Wasm、Wasm VM、用于编写 Wasm 的 SDK，以及跨虚机通信等等。让你对于 Wasm 有了一个初步的认识。</p><p>那从本节课开始呢，我们就进入到具体的编码部分。我会先用两节课的时间，让你了解一下如何编写 Wasm 程序。之后便会带领你做 AI 插件。</p><h2 id="higress-wasm" tabindex="-1"><a class="header-anchor" href="#higress-wasm"><span>Higress Wasm</span></a></h2><p>原生的基于 proxy-wasm-go-sdk 的 Wasm 插件开发比较繁琐，因此 Higress 在这之上封装了一层，从而简化插件开发并且可以增强原生 sdk 的功能。打开 <a href="https://github.com/alibaba/higress/tree/main/plugins/wasm-go/pkg" target="_blank" rel="noopener noreferrer">Higress Wasm 的代码</a>，可以看到文件结构如下：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">tree</span>
<span class="line">.</span>
<span class="line">├── matcher</span>
<span class="line">│   ├── rule_matcher.go</span>
<span class="line">│   ├── rule_matcher_test.go</span>
<span class="line">│   └── utils.go</span>
<span class="line">└── wrapper</span>
<span class="line">    ├── cluster_wrapper.go</span>
<span class="line">    ├── cluster_wrapper_test.go</span>
<span class="line">    ├── http_wrapper.go</span>
<span class="line">    ├── log_wrapper.go</span>
<span class="line">    ├── plugin_wrapper.go</span>
<span class="line">    ├── redis_wrapper.go</span>
<span class="line">    └── request_wrapper.go</span>
<span class="line">    └── response_wrapper.go</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Higress 插件 Go SDK 主要增强功能包括：</p><ul><li><p>matcher 包提供全局、路由、域名级别配置的解析功能。</p></li><li><p>wrapper 包下 log_wrapper.go 封装和简化插件日志的输出功能。</p></li><li><p>wrapper 包下 cluster_wrapper.go、redis_wrapper.go、http_wrapper.go 封装 Http 和 Redis Host Function Call。</p></li><li><p>wrapper 包下 plugin_wrapper.go 封装 proxy-wasm-go-sdk 的 VMContext、PluginContext、HttpContext、插件配置解析功能。</p></li><li><p>wrapper 包下 request_wrapper.go、response_wrapper.go 提供关于请求和响应公共方法。</p></li></ul><p>本节课我们先来介绍一下 plugin_wrapper.go 提供 VMContext、PluginContext、HttpContext、插件配置解析功能。</p><h2 id="higress-wasm-go-sdk-上下文" tabindex="-1"><a class="header-anchor" href="#higress-wasm-go-sdk-上下文"><span>Higress Wasm Go SDK 上下文</span></a></h2><p>在原生 Wasm 中，存在 VMContext、PluginContext、HttpContext 3 个上下文结构体，在 Higress 中对这三个结构体进行了封装，支持了泛型。封装后的结构体名字为 CommonVmCtx、CommonPluginCtx、CommonHttpCtx。</p><p>CommonVmCtx 继承了 DefaultVMContext ，并在此基础上扩充了一些通用的工具方法，例如日志工具、解析函数、HTTP 通信的各个阶段的钩子函数等，其结构体如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">type</span> CommonVmCtx<span class="token punctuation">[</span>PluginConfig any<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// proxy-wasm-go-sdk DefaultVMContext 默认实现</span></span>
<span class="line">    types<span class="token punctuation">.</span>DefaultVMContext</span>
<span class="line">    <span class="token comment">// 插件名称</span></span>
<span class="line">    pluginName                  <span class="token builtin">string</span></span>
<span class="line">    <span class="token comment">// 插件日志工具</span></span>
<span class="line">    log                         Log</span>
<span class="line">    hasCustomConfig             <span class="token builtin">bool</span></span>
<span class="line">    <span class="token comment">// 插件配置解析函数</span></span>
<span class="line">    parseConfig                 ParseConfigFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    <span class="token comment">// 插件路由、域名、服务级别配置解析函数</span></span>
<span class="line">    parseRuleConfig             ParseRuleConfigFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    <span class="token comment">// 以下是自定义插件回调钩子函数</span></span>
<span class="line">    onHttpRequestHeaders        onHttpHeadersFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    onHttpRequestBody           onHttpBodyFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    onHttpStreamingRequestBody  onHttpStreamingBodyFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    onHttpResponseHeaders       onHttpHeadersFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    onHttpResponseBody          onHttpBodyFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    onHttpStreamingResponseBody onHttpStreamingBodyFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    onHttpStreamDone            onHttpStreamDoneFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CommonPluginCtx 则是在 DefaultPluginContext 的基础上提供了更加方便的配置管理等。其结构体如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">type</span> CommonPluginCtx<span class="token punctuation">[</span>PluginConfig any<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// proxy-wasm-go-sdk DefaultPluginContext 默认实现</span></span>
<span class="line">    types<span class="token punctuation">.</span>DefaultPluginContext</span>
<span class="line">    <span class="token comment">// 解析后保存路由、域名、服务级别配置和全局插件配置</span></span>
<span class="line">    matcher<span class="token punctuation">.</span>RuleMatcher<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    <span class="token comment">// 引用 CommonVmCtx</span></span>
<span class="line">    vm          <span class="token operator">*</span>CommonVmCtx<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">    <span class="token comment">// tickFunc 数组</span></span>
<span class="line">    onTickFuncs <span class="token punctuation">[</span><span class="token punctuation">]</span>TickFuncEntry</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CommonHttpCtx 则是在 DefaultHttpContext 基础上扩充了一些流程控制元素。其结构体如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">type</span> CommonHttpCtx<span class="token punctuation">[</span>PluginConfig any<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// proxy-wasm-go-sdk DefaultHttpContext 默认实现</span></span>
<span class="line">  types<span class="token punctuation">.</span>DefaultHttpContext</span>
<span class="line">  <span class="token comment">// 引用 CommonPluginCtx</span></span>
<span class="line">  plugin                <span class="token operator">*</span>CommonPluginCtx<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span></span>
<span class="line">  <span class="token comment">// 当前 Http 上下文下匹配插件配置，可能是路由、域名、服务级别配置或者全局配置</span></span>
<span class="line">  config                <span class="token operator">*</span>PluginConfig</span>
<span class="line">  <span class="token comment">// 是否处理请求体</span></span>
<span class="line">  needRequestBody       <span class="token builtin">bool</span></span>
<span class="line">  <span class="token comment">// 是否处理响应体</span></span>
<span class="line">  needResponseBody      <span class="token builtin">bool</span></span>
<span class="line">  <span class="token comment">// 是否处理流式请求体</span></span>
<span class="line">  streamingRequestBody  <span class="token builtin">bool</span></span>
<span class="line">  <span class="token comment">// 是否处理流式响应体</span></span>
<span class="line">  streamingResponseBody <span class="token builtin">bool</span></span>
<span class="line">  <span class="token comment">// 非流式处理缓存请求体大小</span></span>
<span class="line">  requestBodySize       <span class="token builtin">int</span></span>
<span class="line">  <span class="token comment">// 非流式处理缓存响应体大小</span></span>
<span class="line">  responseBodySize      <span class="token builtin">int</span></span>
<span class="line">  <span class="token comment">// Http 上下文 ID</span></span>
<span class="line">  contextID             <span class="token builtin">uint32</span></span>
<span class="line">  <span class="token comment">// 自定义插件设置自定义插件上下文</span></span>
<span class="line">  userContext           <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们简单看一下这三个上下文的实现。</p><h3 id="启动入口和-vm-上下文-commonvmctx" tabindex="-1"><a class="header-anchor" href="#启动入口和-vm-上下文-commonvmctx"><span>启动入口和 VM 上下文（CommonVmCtx）</span></a></h3><p>CommonVmCtx 的钩子函数在插件中的启动入口如下所示：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  wrapper<span class="token punctuation">.</span><span class="token function">SetCtx</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token comment">// 插件名称</span></span>
<span class="line">    <span class="token string">&quot;hello-world&quot;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数解析插件配置，这个方法适合插件全局配置和路由、域名、服务级别配置内容规则是一样</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ParseConfigBy</span><span class="token punctuation">(</span>parseConfig<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数解析插件全局配置和路由、域名、服务级别配置，这个方法适合插件全局配置和路由、域名、服务级别配置内容规则不一样</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ParseOverrideConfigBy</span><span class="token punctuation">(</span>parseConfig<span class="token punctuation">,</span> parseRuleConfig<span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理请求头</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ProcessRequestHeadersBy</span><span class="token punctuation">(</span>onHttpRequestHeaders<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理请求体</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ProcessRequestBodyBy</span><span class="token punctuation">(</span>onHttpRequestBody<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理响应头</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ProcessResponseHeadersBy</span><span class="token punctuation">(</span>onHttpResponseHeaders<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理响应体</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ProcessResponseBodyBy</span><span class="token punctuation">(</span>onHttpResponseBody<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理流式请求体</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ProcessStreamingRequestBodyBy</span><span class="token punctuation">(</span>onHttpStreamingRequestBody<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理流式响应体</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">ProcessStreamingResponseBodyBy</span><span class="token punctuation">(</span>onHttpStreamingResponseBody<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token comment">// 设置自定义函数处理流式请求完成</span></span>
<span class="line">    wrappper<span class="token punctuation">.</span><span class="token function">ProcessStreamDoneBy</span><span class="token punctuation">(</span>onHttpStreamDone<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际编写插件时，这些不是全必选的，需要根据自己的实际业务来确定需要选哪个钩子。例如，我想拦截 HTTP 请求的 Body，之后针对 Body 的内容做一些操作，就需要通过 wrapper.SetCtx 来设置 wrapper.ProcessRequestBodyBy(onHttpRequestBody)。</p><p>wrapper.SetCtx 的底层实际上就是调用的 Wasm 原生的接口，代码如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">func</span> SetCtx<span class="token punctuation">[</span>PluginConfig any<span class="token punctuation">]</span><span class="token punctuation">(</span>pluginName <span class="token builtin">string</span><span class="token punctuation">,</span> setFuncs <span class="token operator">...</span>SetPluginFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 调用 proxywasm.SetVMContext 设置 VMContext</span></span>
<span class="line">  proxywasm<span class="token punctuation">.</span><span class="token function">SetVMContext</span><span class="token punctuation">(</span><span class="token function">NewCommonVmCtx</span><span class="token punctuation">(</span>pluginName<span class="token punctuation">,</span> setFuncs<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> NewCommonVmCtx<span class="token punctuation">[</span>PluginConfig any<span class="token punctuation">]</span><span class="token punctuation">(</span>pluginName <span class="token builtin">string</span><span class="token punctuation">,</span> setFuncs <span class="token operator">...</span>SetPluginFunc<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span>CommonVmCtx<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span> <span class="token punctuation">{</span></span>
<span class="line">  ctx <span class="token operator">:=</span> <span class="token operator">&amp;</span>CommonVmCtx<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span><span class="token punctuation">{</span></span>
<span class="line">    pluginName<span class="token punctuation">:</span>      pluginName<span class="token punctuation">,</span></span>
<span class="line">    log<span class="token punctuation">:</span>             Log<span class="token punctuation">{</span>pluginName<span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    hasCustomConfig<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// CommonVmCtx 里设置自定义插件回调钩子函数</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> set <span class="token operator">:=</span> <span class="token keyword">range</span> setFuncs <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">set</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token operator">...</span></span>
<span class="line">  <span class="token keyword">return</span> ctx</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="插件上下文-commonpluginctx" tabindex="-1"><a class="header-anchor" href="#插件上下文-commonpluginctx"><span>插件上下文（CommonPluginCtx）</span></a></h3><p>插件上下文主要是用来解析插件配置的，其核心代码在 OnPluginStart  方法中。我们摘取部分核心代码，大概看一下。</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token punctuation">(</span>ctx <span class="token operator">*</span>CommonPluginCtx<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">OnPluginStart</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> types<span class="token punctuation">.</span>OnPluginStartStatus <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 调用 proxywasm.GetPluginConfiguration 获取插件配置</span></span>
<span class="line">  data<span class="token punctuation">,</span> err <span class="token operator">:=</span> proxywasm<span class="token punctuation">.</span><span class="token function">GetPluginConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  globalOnTickFuncs <span class="token operator">=</span> <span class="token boolean">nil</span></span>
<span class="line">  <span class="token operator">...</span></span>
<span class="line">  <span class="token keyword">var</span> jsonData gjson<span class="token punctuation">.</span>Result</span>
<span class="line">  <span class="token comment">// 插件配置转成 json</span></span>
<span class="line">  jsonData <span class="token operator">=</span> gjson<span class="token punctuation">.</span><span class="token function">ParseBytes</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 设置 parseOverrideConfig</span></span>
<span class="line">  <span class="token keyword">var</span> parseOverrideConfig <span class="token keyword">func</span><span class="token punctuation">(</span>gjson<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> PluginConfig<span class="token punctuation">,</span> <span class="token operator">*</span>PluginConfig<span class="token punctuation">)</span> <span class="token builtin">error</span></span>
<span class="line">  <span class="token keyword">if</span> ctx<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>parseRuleConfig <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">    parseOverrideConfig <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>js gjson<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> global PluginConfig<span class="token punctuation">,</span> cfg <span class="token operator">*</span>PluginConfig<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 解析插件路由、域名、服务级别插件配置</span></span>
<span class="line">      <span class="token keyword">return</span> ctx<span class="token punctuation">.</span>vm<span class="token punctuation">.</span><span class="token function">parseRuleConfig</span><span class="token punctuation">(</span>js<span class="token punctuation">,</span> global<span class="token punctuation">,</span> cfg<span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>log<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token operator">...</span></span>
<span class="line">  <span class="token comment">// 解析插件配置</span></span>
<span class="line">  err <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">ParseRuleConfig</span><span class="token punctuation">(</span>jsonData<span class="token punctuation">,</span></span>
<span class="line">    <span class="token keyword">func</span><span class="token punctuation">(</span>js gjson<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> cfg <span class="token operator">*</span>PluginConfig<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 解析插件全局或者当 parseRuleConfig 没有设置时候同时解析路由、域名、服务级别插件配置</span></span>
<span class="line">      <span class="token keyword">return</span> ctx<span class="token punctuation">.</span>vm<span class="token punctuation">.</span><span class="token function">parseConfig</span><span class="token punctuation">(</span>js<span class="token punctuation">,</span> cfg<span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>log<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    parseOverrideConfig<span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line">  <span class="token operator">...</span></span>
<span class="line">  <span class="token keyword">if</span> globalOnTickFuncs <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">    ctx<span class="token punctuation">.</span>onTickFuncs <span class="token operator">=</span> globalOnTickFuncs</span>
<span class="line">    <span class="token operator">...</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> types<span class="token punctuation">.</span>OnPluginStartStatusOK</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现在解析插件配置过程中有两个回调钩子函数，parseConfig 和 parseRuleConfig。</p><ul><li><p>parseConfig ：解析插件全局配置，如果 parseRuleConfig 没有设置，那么 parseConfig 会同时解析全局配置和路由、域名、服务级别配置。也就是说插件全局配置和路由、域名、服务级别配置规则是一样的。</p></li><li><p>parseRuleConfig: 解析路由、域名、服务级别插件配置。如果设置 parseRuleConfig，也就是说插件全局配置和路由、域名、服务级别配置规则是不同的。</p></li></ul><p>在开发插件时，需要注意全局配置和路由、域名、服务级别配置规则是否一致，如果一致，则只调用 parseConfig 即可，如果不一致，就还需要调用 parseRuleConfig。</p><h3 id="http-上下文-commonhttpctx" tabindex="-1"><a class="header-anchor" href="#http-上下文-commonhttpctx"><span>HTTP 上下文（CommonHttpCtx）</span></a></h3><p>HTTP 上下文是 Higress Wasm 插件开发中非常重要的一个部分，它负责处理 HTTP 请求和响应的具体逻辑。通过 CommonHttpCtx，开发者可以访问和操作请求头、请求体、响应头、响应体等关键信息，从而实现各种自定义功能。</p><p>HTTP 上下文的核心功能如下：</p><ul><li><p><strong>请求和响应的处理</strong>：CommonHttpCtx 提供了对 HTTP 请求和响应的全面控制能力。开发者可以通过它读取请求头、请求体、查询参数等信息，并根据需要修改响应头、响应体等内容。例如，可以在  onHttpRequestHeaders  钩子中检查请求头中的认证信息，或者在  onHttpResponseBody  钩子中对响应体进行加密或压缩。</p></li><li><p><strong>流式处理</strong>：CommonHttpCtx 支持流式处理请求体和响应体。这对于处理大文件或实时数据流非常有用。通过  onHttpStreamingRequestBody  和  onHttpStreamingResponseBody  钩子，开发者可以逐块处理请求体或响应体，而不需要一次性加载整个内容。</p></li><li><p><strong>配置管理</strong>：CommonHttpCtx 可以访问插件配置，这些配置可以是全局配置，也可以是针对特定路由、域名或服务的配置。通过  config  字段，开发者可以根据不同的配置执行不同的逻辑。例如，某些路由可能需要特殊的认证逻辑，而其他路由则不需要。</p></li><li><p><strong>上下文管理</strong>：CommonHttpCtx 提供了  userContext  字段，允许开发者在 HTTP 请求的生命周期内存储和共享自定义数据。这对于需要在多个钩子函数之间传递数据的场景非常有用。例如，可以在  onHttpRequestHeaders  钩子中解析用户信息，并将其存储在  userContext  中，以便在后续的钩子中使用。</p></li></ul><p>除此之外，在 Higress Wasm 插件中，HTTP 上下文的钩子函数是开发者实现自定义逻辑的关键。以下是一些常用的钩子函数：</p><ul><li><p>onHttpRequestHeaders：在接收到请求头时触发。可以用于检查请求头中的认证信息、修改请求头等。</p></li><li><p>onHttpRequestBody：在接收到请求体时触发。可以用于解析请求体内容、修改请求体等。</p></li><li><p>onHttpResponseHeaders：在接收到响应头时触发。可以用于修改响应头、添加自定义头等。</p></li><li><p>onHttpResponseBody：在接收到响应体时触发。可以用于修改响应体内容、加密或压缩响应体等。</p></li><li><p>onHttpStreamingRequestBody：在接收到流式请求体时触发。可以用于逐块处理请求体。</p></li><li><p>onHttpStreamingResponseBody：在接收到流式响应体时触发。可以用于逐块处理响应体。</p></li><li><p>onHttpStreamDone：在流式处理完成时触发。可以用于清理资源或执行最终的处理逻辑。</p></li></ul><p>我们用一个简单的示例，展示一下如何使用 CommonHttpCtx 实现一个检查请求头中是否包含特定字段的插件，代码如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">package</span> main</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token string">&quot;github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper&quot;</span></span>
<span class="line">    <span class="token string">&quot;github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm&quot;</span></span>
<span class="line">    <span class="token string">&quot;github.com/tetratelabs/proxy-wasm-go-sdk/proxywasm/types&quot;</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    wrapper<span class="token punctuation">.</span><span class="token function">SetCtx</span><span class="token punctuation">(</span></span>
<span class="line">        <span class="token string">&quot;check-header&quot;</span><span class="token punctuation">,</span></span>
<span class="line">        wrapper<span class="token punctuation">.</span><span class="token function">ParseConfigBy</span><span class="token punctuation">(</span>parseConfig<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        wrapper<span class="token punctuation">.</span><span class="token function">ProcessRequestHeadersBy</span><span class="token punctuation">(</span>onHttpRequestHeaders<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> PluginConfig <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    RequiredHeader <span class="token builtin">string</span> <span class="token string">\`json:&quot;requiredHeader&quot;\`</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">parseConfig</span><span class="token punctuation">(</span>json gjson<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> config <span class="token operator">*</span>PluginConfig<span class="token punctuation">,</span> log wrapper<span class="token punctuation">.</span>Log<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span></span>
<span class="line">    config<span class="token punctuation">.</span>RequiredHeader <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">&quot;requiredHeader&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">nil</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">onHttpRequestHeaders</span><span class="token punctuation">(</span>ctx <span class="token operator">*</span>wrapper<span class="token punctuation">.</span>CommonHttpCtx<span class="token punctuation">[</span>PluginConfig<span class="token punctuation">]</span><span class="token punctuation">,</span> numHeaders <span class="token builtin">int</span><span class="token punctuation">,</span> endOfStream <span class="token builtin">bool</span><span class="token punctuation">)</span> types<span class="token punctuation">.</span>Action <span class="token punctuation">{</span></span>
<span class="line">    requiredHeader <span class="token operator">:=</span> ctx<span class="token punctuation">.</span>config<span class="token punctuation">.</span>RequiredHeader</span>
<span class="line">    value<span class="token punctuation">,</span> err <span class="token operator">:=</span> proxywasm<span class="token punctuation">.</span><span class="token function">GetHttpRequestHeader</span><span class="token punctuation">(</span>requiredHeader<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">{</span></span>
<span class="line">        proxywasm<span class="token punctuation">.</span><span class="token function">SendHttpResponse</span><span class="token punctuation">(</span><span class="token number">403</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">&quot;Missing required header: &quot;</span><span class="token operator">+</span>requiredHeader<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> types<span class="token punctuation">.</span>ActionPause</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> types<span class="token punctuation">.</span>ActionContinue</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，插件会检查请求头中是否包含配置中指定的字段。如果缺少该字段，插件会返回 403 状态码并终止请求。</p><h3 id="types-action" tabindex="-1"><a class="header-anchor" href="#types-action"><span>Types.Action</span></a></h3><p>在 Higress Wasm 插件开发中，Types.Action  是一个非常重要的枚举类型，它用于控制 HTTP 请求和响应的处理流程。通过返回不同的  Types.Action  值，开发者可以决定是否继续处理请求或者暂停处理。在自定义插件中 onHttpRequestHeaders、onHttpRequestBody、onHttpResponseHeaders、onHttpResponseBody 返回值类型为 types.Action。通过 types.Action 枚举值来控制插件的运行流程，常见的返回值有 2 个。</p><p>一个是 types.ActionContinue，继续后续处理，比如继续读取请求 body，或者继续读取响应 body；另一个是 types.ActionPause，暂停后续处理，比如在 onHttpRequestHeaders 通过 Http 或者 Redis 调用外部服务获取认证信息，在调用外部服务回调钩子函数中调用 proxywasm.ResumeHttpRequest() 来恢复后续处理 或者调用 proxywasm.SendHttpResponseWithDetail() 来返回响应。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>在本节课中，我们深入探讨了 Higress Wasm 插件的开发，特别是如何通过 Higress 封装的 Go SDK 来简化 Wasm 插件的开发流程。我们首先介绍了 Higress Wasm 的代码结构和主要功能，包括  matcher  包和  wrapper  包的作用。接着，我们详细讲解了 Higress 中的三个核心上下文结构体：CommonVmCtx、CommonPluginCtx  和  CommonHttpCtx，它们分别对应 Wasm 原生的  VMContext、PluginContext  和  HttpContext，并在其基础上进行了功能增强。</p><p>通过  CommonVmCtx，我们可以轻松地管理插件的生命周期，设置各种钩子函数来处理 HTTP 请求和响应的不同阶段。CommonPluginCtx  则提供了插件配置的解析功能，支持全局配置和路由、域名、服务级别的配置管理。而  CommonHttpCtx  则是处理 HTTP 请求和响应的核心，开发者可以通过它访问和操作请求头、请求体、响应头、响应体等内容，实现各种自定义逻辑。</p><p>我们还通过一个简单的示例，展示了如何使用  CommonHttpCtx  来实现一个检查请求头中是否包含特定字段的插件。这个示例帮助我们理解了如何通过  types.Action  来控制插件的处理流程，以及如何在插件中返回自定义的 HTTP 响应。</p><p>在下节课，我会用具体的实际小例子，带你体会完整的 Wasm 插件开发流程。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>Higress Wasm 提供了多个钩子函数来处理 HTTP 请求和响应的不同阶段，如  onHttpRequestHeaders、onHttpRequestBody、onHttpResponseHeaders  等。假设你需要开发一个插件，要求对请求体进行加密处理，并在响应体中返回加密后的结果。你会选择哪些钩子函数来实现这个功能，为什么？</p>`,49)]))}const c=s(t,[["render",i]]),u=JSON.parse('{"path":"/3.tech/84.AIAgent/20.Wasm%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89.html","title":"Wasm 编程基础（上）","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"Higress Wasm","slug":"higress-wasm","link":"#higress-wasm","children":[]},{"level":2,"title":"Higress Wasm Go SDK 上下文","slug":"higress-wasm-go-sdk-上下文","link":"#higress-wasm-go-sdk-上下文","children":[{"level":3,"title":"启动入口和 VM 上下文（CommonVmCtx）","slug":"启动入口和-vm-上下文-commonvmctx","link":"#启动入口和-vm-上下文-commonvmctx","children":[]},{"level":3,"title":"插件上下文（CommonPluginCtx）","slug":"插件上下文-commonpluginctx","link":"#插件上下文-commonpluginctx","children":[]},{"level":3,"title":"HTTP 上下文（CommonHttpCtx）","slug":"http-上下文-commonhttpctx","link":"#http-上下文-commonhttpctx","children":[]},{"level":3,"title":"Types.Action","slug":"types-action","link":"#types-action","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"思考题","slug":"思考题","link":"#思考题","children":[]}],"git":{"updatedTime":1749262836000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":1,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"0e82c49946907ddefcb6ccb279dc6debbb8ca726","time":1749262836000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"add 20250607"}]},"filePathRelative":"3.tech/84.AIAgent/20.Wasm 编程基础（上）.md"}');export{c as comp,u as data};
