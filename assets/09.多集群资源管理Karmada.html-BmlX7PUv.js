import{_ as a,c as s,a as e,o as p}from"./app-Dmwo-0Oh.js";const t={};function i(l,n){return p(),s("div",null,n[0]||(n[0]=[e(`<h1 id="多集群资源管理-karmada" tabindex="-1"><a class="header-anchor" href="#多集群资源管理-karmada"><span>多集群资源管理 Karmada</span></a></h1><p>在前几节课中，我们围绕单 Kubernetes 集群的资源如何操控，做了详细的介绍以及代码实践。但随着企业业务的发展和对云原生技术应用的深入，越来越多的企业开始面临管理多个 Kubernetes 集群的需求。这些集群可能分布在不同的云供应商、地理位置或边缘设备上，以满足不同场景下的性能、成本及合规性要求。因此，本节课我将为你介绍一款由华为开源的多集群管理软件--Karmada，并讲解如何通过动态客户端等方式通过 Karmada 来操作多集群。</p><p>首先我们先来认识一下 Karmada。</p><h2 id="什么是-karmada" tabindex="-1"><a class="header-anchor" href="#什么是-karmada"><span>什么是 Karmada？</span></a></h2><p>Karmada 是一个由华为开源的云原生多云容器编排平台，目标是让开发者像使用单个 Kubernetes 集群一样使用多个 Kubernetes 集群。开发者可以在多个 Kubernetes 集群和云中运行云原生应用程序，而无需更改应用程序。Karmda 的架构图如下：</p><p><img src="https://static001.geekbang.org/resource/image/0f/80/0fa97cyyb6b61190143e38518df57b80.png?wh=1706x1127" alt="图片"></p><p>可以看到 Karmada 在架构上，参考了很多 Kubernetes 的设计，比如 apiserver、调度器 scheduer、controller-manager、etcd 等等。因此用户可以像访问普通 Kubernetes 一样，通过命令行，Rest API（client-go）等方式来访问 karmada。</p><p>Karmada 纳管集群的方式有两种，一种是 Push 模式，一种是 Pull 模式。使用 Push 模式，Karmada 会直接访问成员的 apiserver。而 Pull 模式，则需要在成员集群上，安装一个 agent 代理，通过代理访问 apiserver。</p><p>总的来说，由于 Karmada 使用聚合 API 技术，使得它能够兼容原生 K8s API，因此对于开发者来说，使用起来非常友好，用 Karmada 来做多集群资源的查询、差异化分发等等操作都很方便。</p><p>在了解了什么是 Karmada 后，我们来看看如何安装。</p><h2 id="karmada-环境搭建" tabindex="-1"><a class="header-anchor" href="#karmada-环境搭建"><span>Karmada 环境搭建</span></a></h2><p>这节课我们会使用两台 Kubernetes 集群来测试 Karmada。其中一台作为主集群，Karmada 会运行在该集群上，另外一台集群当作从集群。架构如下：</p><p><img src="https://static001.geekbang.org/resource/image/0e/97/0eaa1b9f5b8276c96b54c774fa695a97.jpg?wh=1482x933" alt="图片"></p><p>如果你的手上没有这么多服务器，可以使用 Kind 工具在一台服务器上创建出多个集群。</p><h3 id="kind" tabindex="-1"><a class="header-anchor" href="#kind"><span>Kind</span></a></h3><p>Kind 是 Kubernetes In Docker 的缩写，是将 Kuberntes 各节点运行在 docker 容器内，从而快速拉起集群的一种工具。我们可以用 Kind 来快速创建不同版本的集群，从而方便测试。</p><p><strong>环境与工具准备</strong></p><p>使用 Kind ，首先需要有一台安装了 docker 的服务器。在这里，我使用的是云服务器，操作系统是 Ubuntu 20.04，docker 版本是 27.0.2。之后需要安装 Kind 命令工具来帮助我们创建删除集群等。</p><p>那 Kind 工具如何安装呢？首先，我们需要打开 Github 链接：<a href="https://github.com/kubernetes-sigs/kind/releases" target="_blank" rel="noopener noreferrer">Releases · kubernetes-sigs/kind</a>，选择自己喜欢的版本下载，我使用的版本是 v0.24.0，如果你想要跟我一样的效果，建议和我的版本保持一致。</p><p><img src="https://static001.geekbang.org/resource/image/a3/67/a32e982fa709a3d4bb9d26673af3fb67.png?wh=1372x685" alt="图片"></p><p>我们点开对应版本的 Asserts，下载自己操作系统版本的压缩包。以 linux 系统为例，下载后，将压缩包放到 linux 系统的 /usr/local/bin 下解压，得到 Kind 二进制文件，之后给 Kind 赋可执行权限即可。</p><p><img src="https://static001.geekbang.org/resource/image/f5/a2/f58fa6ddc471dbe90f4a3272180d69a2.png?wh=482x52" alt="图片"></p><p><strong>创建集群</strong></p><p>准备好 Kind 工具后，我们来通过 Yaml 模板的方式创建两个集群，一个是主集群，一个是从集群。</p><p>首先是主集群的 Yaml 模板。</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml"><pre><code><span class="line"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Cluster</span>
<span class="line"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kind.x<span class="token punctuation">-</span>k8s.io/v1alpha4</span>
<span class="line"><span class="token key atrule">name</span><span class="token punctuation">:</span> test1  <span class="token comment">#第1个集群</span></span>
<span class="line"><span class="token key atrule">nodes</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> control<span class="token punctuation">-</span>plane</span>
<span class="line">    image<span class="token punctuation">:</span> kindest/node<span class="token punctuation">:</span>v1.24.15</span>
<span class="line">    extraPortMappings<span class="token punctuation">:</span></span>
<span class="line">      <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6443</span></span>
<span class="line">        hostPort<span class="token punctuation">:</span> 36443  <span class="token comment">#安全组开放</span></span>
<span class="line">        protocol<span class="token punctuation">:</span> tcp</span>
<span class="line">      <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">31443</span></span>
<span class="line">        hostPort<span class="token punctuation">:</span> 31443  <span class="token comment">#安全组开放   这是karmada的 apiserver端口 ,装在 test1上的</span></span>
<span class="line">        protocol<span class="token punctuation">:</span> tcp</span>
<span class="line">  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> worker</span>
<span class="line">    image<span class="token punctuation">:</span> kindest/node<span class="token punctuation">:</span>v1.24.15</span>
<span class="line"><span class="token key atrule">networking</span><span class="token punctuation">:</span></span>
<span class="line">  apiServerAddress<span class="token punctuation">:</span> <span class="token string">&quot;192.168.67.99&quot;</span> <span class="token comment"># 云服务器内网地址</span></span>
<span class="line">  apiServerPort<span class="token punctuation">:</span> <span class="token number">6443</span></span>
<span class="line">  podSubnet<span class="token punctuation">:</span> <span class="token string">&quot;10.6.0.0/16&quot;</span> <span class="token comment">#自定义 pod IP 地址范围</span></span>
<span class="line">  serviceSubnet<span class="token punctuation">:</span> <span class="token string">&quot;10.96.0.0/16&quot;</span></span>
<span class="line">  kubeProxyMode<span class="token punctuation">:</span> <span class="token string">&quot;ipvs&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板中，集群包含两个 Node，一个是控制面 control-plane，也就是 master 节点，另一个是 worker 节点，节点的版本都是 v1.24.15。其中 master 节点映射出了两个端口，分别是 6443-&gt;36443，31443-&gt;31443 ，这是因为 Kubernetes 是安装到 docker 容器内的，如果想要外部访问，必须映射端口。6443 表示 apiserver 端口，31443 表示 karmada apiserver 端口。</p><p>在网络方面，apiserver 的地址，我填写了云服务器内网地址。然后在 podSubnet 自定义了 pod 的 ip 网段，在 serviceSubnet 自定义了 服务网络网段。</p><p>从集群的配置与主集群基本一致，只是无需映射 31443 端口，同时 podSubnet 和 serviceSubnet 尽量与主集群不一致，方便做一些 pod 互通之类的操作。</p><p>准备好配置文件后，只需执行下面这行代码：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">kind create cluster --config=c.yaml</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>即可完成集群创建，完成创建后，会自动在 ~/.kube/ 目录下创建 config 文件，此时使用 kubectl 就可以操作集群了。</p><p>这节课的所有配置以及代码，我都会上传到 Github，届时你用我的配置做测试即可。</p><h3 id="karmada-创建" tabindex="-1"><a class="header-anchor" href="#karmada-创建"><span>Karmada 创建</span></a></h3><p>Karmada 我使用的版本是 v1.10.7，安装官方提供了很多方式，比如通过 Karmadactl 命令行，或者 helm 等等。今天我们来讲一下使用 helm chart 安装的方法。</p><p><strong>安装</strong></p><p>Helm 部署首先需要下载 [chart 包](https://Releases · karmada-io/karmada)。</p><p><img src="https://static001.geekbang.org/resource/image/ec/cc/ec52b9c2a10ddb40yy010bb2a14192cc.png?wh=1366x663" alt="图片"></p><p>找到 v1.10.7 版本，下载 karmada-chat-v1.10.7.tgz 压缩文件，在服务器上解压即可。你也顺便将 karmadactl 下载下来，放到 /usr/local/bin 中，后面纳管集群等操作会用到。</p><p>解压 chart 包后，我们需要修改 values.yaml 中的几个点：</p><ol><li><p>由于网络原因，global 下的 imageRegistry，需要改成 DockerHub 的国内代理地址，如果你手里没有国内可用代理地址，可以在留言区留言。</p></li><li><p>apiServer 的 image 下的 repository 改成 myifeng/k8s.gcr.io_kube-apiserver。</p></li><li><p>apiServer 的 serviceType 改成 NodePort，nodeport 端口改成 31443。</p></li><li><p>kubeControllerManager 的 image 下的 repository 改成 myifeng/k8s.gcr.io_kube-controller-manager。</p></li><li><p>etcd 的 image 下的 repository 改成 myifeng/k8s.gcr.io_etcd。</p></li><li><p>certs 下的 hosts，添加上云服务器的公网 ip，否则无法通过公网访问 Karmada。</p></li></ol><p>修改完成后，执行命令，进行安装：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">helm install karmada karmada -n karmada-system --create-namespace</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用 kubectl get po -n karmada-system 查看 pod 状态。当所有 pod 都 running 时，安装就成功了。</p><p><img src="https://static001.geekbang.org/resource/image/2d/4c/2d59c86994792d6a0ed591757420464c.png?wh=953x223" alt="图片"></p><p>通过下面的命令，可以将 karmada 的 kubeconfig 文件保存下来。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">kubectl get secret karmada-kubeconfig  -n karmada-system  -o jsonpath={.data.kubeconfig} | base64 -d &gt; karmada-config</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>之后修改 karmada-config 文件的 server，从 https://karmada-apiserver.karmada-system.svc.cluster.local:5443 改为 https://&lt;公网 ip&gt;:31443，使得可以通过公网访问 karmada。</p><p><strong>纳管集群</strong></p><p>方便起见，我们使用 Push 方法来纳管集群。执行如下命令，纳管集群 test1。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">karmadactl join member1 --kubeconfig=/root/kind/karmada/karmada-config --cluster-kubeconfig=&#39;/root/.kube/config&#39;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该命令的含义是通过 karmadactl 工具，用上面保存下来的 karmada-config 文件来访问 Karmada 的 apiserver，之后通过 join 命令，利用 test1 集群的 config 文件，访问 test1 的 apiserver，从而实现集群纳管，纳管后，该集群在 Karmada 中命名为 member1。</p><p>纳管后，我们通过 kubectl 可以查询集群列表。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">kubectl --kubeconfig ./karmada-config get clusters</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>效果如下：</p><p><img src="https://static001.geekbang.org/resource/image/1b/2f/1b6b5ee6d630ea319d9475f513a1a42f.png?wh=956x75" alt="图片"></p><p>此时，你可能会问，为什么查看集群列表是用 kubectl 呢？这是因为上文讲过 Karmada 是使用了聚合 API 技术，相当于自己造了一个小型 apiserver 挂到了 Kubernetes 集群的 apiserver 上，因此通过 kubectl 可以查到 karmada 的 自定义 API。查询方法是输入命令：</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">kubectl get apiservice --kubeconfig kind/karmada/karmada-config</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结果：</p><p><img src="https://static001.geekbang.org/resource/image/15/8c/1557664c5a6f3d7e5efe16e77ae3858c.png?wh=1156x772" alt="图片"></p><p>可以看到红框中的 API，全是 karmada 自定义的。</p><p>在完成第一个集群纳管后，你可以使用我代码中的 c2.yaml 创建出第二个 kind 集群，然后使用如下命令将第二个集群纳管进来。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">karmadactl join member2 --kubeconfig=/root/kind/karmada/karmada-config --cluster-kubeconfig=&#39;/root/.kube/config&#39; --cluster-context=&#39;kind-test2&#39;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>得到如下的效果：</p><p><img src="https://static001.geekbang.org/resource/image/ac/9b/ac365291fbcebf2b1d6f13ceeab3df9b.png?wh=979x103" alt="图片"></p><p>至此，Karmada 的环境搭建部分就完成了。</p><h2 id="karmada-代码实战" tabindex="-1"><a class="header-anchor" href="#karmada-代码实战"><span>Karmada 代码实战</span></a></h2><p>由于我们要让 Agent 来进行多集群管理，因此需要通过代码的方式操作 Karmada，以便封装成工具。</p><p>通过前面 client-go 部分的学习，我们知道动态客户端可以操作任意资源，包括自定义资源 CRD。因此使用动态客户端操控 Karmada，一定是没问题的。但实际上， Karmada 本身也有自己实现的 client，可以更加方便地操作 Karmada 资源，接下来，我以获取集群列表为例，为你演示一下这两种方法。</p><h3 id="动态客户端" tabindex="-1"><a class="header-anchor" href="#动态客户端"><span>动态客户端</span></a></h3><p>首先演示一下使用动态客户端操作 Karmada 的代码实现。动态客户端的初始化大家已经很熟悉了，我就不再演示。只需要注意一点，客户端所使用的 config 文件，要替换成 karmada-config。</p><p>获取集群列表的代码这样写：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    config <span class="token operator">:=</span> config<span class="token punctuation">.</span><span class="token function">NewK8sConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InitRestConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    ri <span class="token operator">:=</span> config<span class="token punctuation">.</span><span class="token function">InitDynamicClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    clusterGvr <span class="token operator">:=</span> schema<span class="token punctuation">.</span>GroupVersionResource<span class="token punctuation">{</span></span>
<span class="line">        Group<span class="token punctuation">:</span>    <span class="token string">&quot;cluster.karmada.io&quot;</span><span class="token punctuation">,</span></span>
<span class="line">        Version<span class="token punctuation">:</span>  <span class="token string">&quot;v1alpha1&quot;</span><span class="token punctuation">,</span></span>
<span class="line">        Resource<span class="token punctuation">:</span> <span class="token string">&quot;clusters&quot;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    list<span class="token punctuation">,</span> err <span class="token operator">:=</span> ri<span class="token punctuation">.</span><span class="token function">Resource</span><span class="token punctuation">(</span>clusterGvr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">List</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span>ListOptions<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> item <span class="token operator">:=</span> <span class="token keyword">range</span> list<span class="token punctuation">.</span>Items <span class="token punctuation">{</span></span>
<span class="line">        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码没什么稀奇的，主要是 GVR 我是怎么知道的呢？我是通过如下命令查到的：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line">kubectl api<span class="token operator">-</span>resources <span class="token operator">--</span>kubeconfig kind<span class="token operator">/</span>karmada<span class="token operator">/</span>karmada<span class="token operator">-</span>config <span class="token operator">|</span> grep cluster</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="https://static001.geekbang.org/resource/image/8a/3b/8aee949ca75e733ce63c5d5124e6cc3b.png?wh=1336x51" alt="图片"></p><h3 id="karmada-client" tabindex="-1"><a class="header-anchor" href="#karmada-client"><span>Karmada client</span></a></h3><p>如果你用 kubebuilder 等脚手架开发过 operator 就会知道，脚手架会帮助我们生成框架代码，其中就包括 client。而通过阅读源码可以得知 Karmada 的 client 也是自动生成的，这里我给出了[代码的链接](https://karmada/pkg/generated/clientset/versioned/clientset.go at v1.10.7 · karmada-io/karmada)，我们只需要在代码中初始化该客户端，就可以使用。初始化代码如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">(</span></span>
<span class="line">    karmadaversiond <span class="token string">&quot;github.com/karmada-io/karmada/pkg/generated/clientset/versioned&quot;</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token punctuation">(</span>k <span class="token operator">*</span>K8sConfig<span class="token punctuation">)</span> <span class="token function">InitClientSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>karmadaversiond<span class="token punctuation">.</span>Clientset <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> k<span class="token punctuation">.</span>Config <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        k<span class="token punctuation">.</span>e <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">&quot;k8s config is nil&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;init k8s client failed&quot;</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">nil</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    clientSet<span class="token punctuation">,</span> err <span class="token operator">:=</span> karmadaversiond<span class="token punctuation">.</span><span class="token function">NewForConfig</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span>Config<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        k<span class="token punctuation">.</span>e <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">&quot;init karmada clientSet failed&quot;</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">nil</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> clientSet</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先需要 import 一下 client 包，之后与 clientSet 一样调用 NewForConfig 进行客户端初始化。初始化完成后，列出集群列表就更简单了，代码如下：</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    config <span class="token operator">:=</span> config<span class="token punctuation">.</span><span class="token function">NewK8sConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InitRestConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    client <span class="token operator">:=</span> config<span class="token punctuation">.</span><span class="token function">InitClientSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    clusters<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">ClusterV1alpha1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Clusters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">List</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span>ListOptions<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> item <span class="token operator">:=</span> <span class="token keyword">range</span> clusters<span class="token punctuation">.</span>Items <span class="token punctuation">{</span></span>
<span class="line">        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以说会用 clientSet，就会用 Karmada Client。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>今天这节课，我为你介绍了多 Kubernetes 集群管理工具 Karmada，并带你实操了 Karmada 的安装以及多集群的纳管。最后以获取集群列表为例，介绍了两种用代码实现访问 Karmada 资源的手法。通过 Karmada，我们可以在多个集群之间实现高效的资源调度与管理，解决跨集群操作的复杂性。本节课的 Kind 以及 Karmada 创建的 YAML 以及代码，我已经上传至 <a href="https://github.com/xingyunyang01/Geek/tree/main/karmada" target="_blank" rel="noopener noreferrer">Github</a>，你可以把代码下载下来，实操一遍，加深理解。</p><p>随着企业 IT 架构逐步向云边端一体化转型，Karmada 展现出的不仅仅是集群管理的能力，它在云边端多云环境的管理上也具有巨大的潜力。比如，随着 5G、物联网等新兴技术的发展，边缘计算逐渐成为云计算的重要补充。边缘设备的部署通常分布在远程地区，且面临着带宽、延迟、可靠性等挑战。通过 Karmada，用户可以更轻松地将 Kubernetes 管理的能力延伸到边缘集群，实现跨云、跨地域、跨边缘设备的统一调度和管理，从而提升业务的可靠性和灵活性。</p><p>Karmada 与 AI Agent 结合后，更是如虎添翼，AI Agent 能够为 Karmada 提供智能化的决策支持与自动化操作，使 Karmada 从被动的管理模式转变为主动的智能调度和优化模式。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>有兴趣的话你可以通过阅读文档，学习一下 PropagationPolicy，也就是 Karmada 的资源分发策略，并尝试使用 YAML 的方式，在两个集群上同时拉起 nginx deployment。</p>`,88)]))}const o=a(t,[["render",i]]),r=JSON.parse('{"path":"/3.tech/84.AIAgent/09.%E5%A4%9A%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86Karmada.html","title":"多集群资源管理 Karmada","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"什么是 Karmada？","slug":"什么是-karmada","link":"#什么是-karmada","children":[]},{"level":2,"title":"Karmada 环境搭建","slug":"karmada-环境搭建","link":"#karmada-环境搭建","children":[{"level":3,"title":"Kind","slug":"kind","link":"#kind","children":[]},{"level":3,"title":"Karmada 创建","slug":"karmada-创建","link":"#karmada-创建","children":[]}]},{"level":2,"title":"Karmada 代码实战","slug":"karmada-代码实战","link":"#karmada-代码实战","children":[{"level":3,"title":"动态客户端","slug":"动态客户端","link":"#动态客户端","children":[]},{"level":3,"title":"Karmada client","slug":"karmada-client","link":"#karmada-client","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"思考题","slug":"思考题","link":"#思考题","children":[]}],"git":{"updatedTime":1749262836000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":1,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"0e82c49946907ddefcb6ccb279dc6debbb8ca726","time":1749262836000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"add 20250607"}]},"filePathRelative":"3.tech/84.AIAgent/09.多集群资源管理Karmada.md"}');export{o as comp,r as data};
