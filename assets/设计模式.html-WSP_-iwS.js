import{_ as d,c as e,a as r,o as a}from"./app-Dmwo-0Oh.js";const h={};function o(i,t){return a(),e("div",null,t[0]||(t[0]=[r('<h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h1><h2 id="创建型设计模式" tabindex="-1"><a class="header-anchor" href="#创建型设计模式"><span>创建型设计模式</span></a></h2><table><thead><tr><th>创建型设计模式</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>抽象工厂模式(Abstract Factory)</td><td>提供一个接口，可以创建一系列相关或相互依赖的对象，而无须制定它们具体的类</td><td>抽象接口</td></tr><tr><td>构建器模式(Builder)</td><td>将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示</td><td>类和构造分离</td></tr><tr><td>工厂方法模式(Factory Method)</td><td>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。使得子类实例化过程推迟</td><td>子类决定实例化</td></tr><tr><td>原型模式(Prototype)</td><td>用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象</td><td>原型实例，拷贝</td></tr><tr><td>单例模式(Singleton)</td><td>保证一个类只有一个实例，并提供一个访问它的全局访问点</td><td>唯一实例</td></tr></tbody></table><h2 id="结构型设计模式" tabindex="-1"><a class="header-anchor" href="#结构型设计模式"><span>结构型设计模式</span></a></h2><table><thead><tr><th>结构型设计模式</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>适配器模式(Adapter)</td><td>将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作</td><td>转换，兼容接口</td></tr><tr><td>桥接模式(Bridge)</td><td>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化</td><td>抽象和实现分离</td></tr><tr><td>组合模式(Composite)</td><td>将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</td><td>整体-部分，树型接口</td></tr><tr><td>装饰模式(Decorator)</td><td>动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活</td><td>附加职责</td></tr><tr><td>外观模式(Facade)</td><td>定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用</td><td>对外统一接口</td></tr><tr><td>享元模式(Flyweight)</td><td>提供支持大量细粒度对象共享的有效方法</td><td>细粒度，共享</td></tr><tr><td>代理模式(Proxy)</td><td>为其他对象提供一种代理以控制这个对象的访问</td><td>代理控制</td></tr></tbody></table><h2 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式"><span>行为型设计模式</span></a></h2><table><thead><tr><th>行为型设计模式</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>职责链模式(Chain of Responsibility)</td><td>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，知道由一个对象处理这个请求</td><td>传递请求，职责，链接</td></tr><tr><td>命令模式(Command)</td><td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</td><td>日志记录，可撤销</td></tr><tr><td>解释器模式(Interpreter)</td><td>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</td><td>解释器，虚拟机</td></tr><tr><td>迭代器模式(Iterator)</td><td>提供一种方法来顺序访问一个聚合对象中的各个元素而不需要暴露该对象的内部表示</td><td>顺序访问，不暴露内部</td></tr><tr><td>中介者模式(Mediator)</td><td>用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互</td><td>不直接引用</td></tr><tr><td>备忘录模式(Memento)</td><td>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态</td><td>保存，恢复</td></tr><tr><td>观察者模式(Observer)</td><td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</td><td>通知，自动更新</td></tr><tr><td>状态模式(State)</td><td>允许一个对象在其内部状态改变时改变它的行为</td><td>状态变成类</td></tr><tr><td>策略模式(Strategy)</td><td>定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化</td><td>算法替换</td></tr><tr><td>模板方法模式(Template Method)</td><td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤</td><td>定义算法骨架，然后再细化</td></tr><tr><td>访问者模式(Visitor)</td><td>表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作</td><td>数据和操作分离</td></tr></tbody></table>',7)]))}const c=d(h,[["render",o]]),l=JSON.parse('{"path":"/3.tech/01.tech-arch/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"设计模式","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"创建型设计模式","slug":"创建型设计模式","link":"#创建型设计模式","children":[]},{"level":2,"title":"结构型设计模式","slug":"结构型设计模式","link":"#结构型设计模式","children":[]},{"level":2,"title":"行为型设计模式","slug":"行为型设计模式","link":"#行为型设计模式","children":[]}],"git":{"updatedTime":1745032055000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":2,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"a2b6e78156eb7f1fed6ecb0952cc98c6b90aa9d3","time":1745032055000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"change hierarchy"},{"hash":"54548c8a043329c32ac9406d8ae1d67030640f6c","time":1729164517000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update20241017"}]},"filePathRelative":"3.tech/01.tech-arch/设计模式.md"}');export{c as comp,l as data};
