import{_ as s,c as a,b as p,o as e}from"./app-C01vnHKY.js";const t={};function i(o,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="实战篇-图像分类-下-如何构建一个图像分类模型" tabindex="-1"><a class="header-anchor" href="#实战篇-图像分类-下-如何构建一个图像分类模型"><span>实战篇-图像分类（下）：如何构建一个图像分类模型</span></a></h1><p>我相信经过上节课的学习，你已经了解了图像分类的原理，还初步认识了一些经典的卷积神经网络。</p><p>正所谓“纸上得来终觉浅，绝知此事要躬行”，今天就让我们把上节课的理论知识应用起来，一起从数据的准备、模型训练以及模型评估，从头至尾一起来完成一个完整的图像分类项目实践。</p><p>课程代码你可以从<a href="https://github.com/syuu1987/geekTime-image-classification" target="_blank" rel="noopener noreferrer">这里</a>下载。</p><h2 id="问题回顾" tabindex="-1"><a class="header-anchor" href="#问题回顾"><span>问题回顾</span></a></h2><p>我们先来回顾一下问题背景，我们要解决的问题是，在众多图片中自动识别出极客时间 Logo 的图片。想要实现自动识别，首先需要分析数据集里的图片是啥样子的。</p><p>那我们先来看一张包含极客时间 Logo 的图片，如下所示。</p><p>你可以看到，Logo 占整张图片的比例还是比较小的，所以说，如果这个项目是真实存在的，目标检测其实更加合适。不过，我们可以将问题稍微修改一下，修改成自动识别极客时间宣传海报，这其实就很适合图像分类任务了。</p><h2 id="数据准备" tabindex="-1"><a class="header-anchor" href="#数据准备"><span>数据准备</span></a></h2><p>相比目标检测与图像分割来说，图像分类的数据准备还是比较简单的。在图像分类中，我们只需要将每个类别的图片放到指定的文件夹里就行了。</p><p>下图是我的图片组织方式，文件夹就是图片所属的类别。</p><p><img src="https://static001.geekbang.org/resource/image/cf/8e/cf664db8d071979583a7cec69a45168e.png?wh=922x334" alt="图片"></p><p>logo 文件夹中存放的是 10 张极客时间海报的图片。</p><p><img src="https://static001.geekbang.org/resource/image/46/27/460af80104ec4550ff1b745a1f9f6627.png?wh=1516x704" alt="图片"></p><p>而 others 中，理论上应该是各种其它类型的图片，但这里为了简化问题，我这个文件夹中存放的都是小猫的图片。</p><p><img src="https://static001.geekbang.org/resource/image/e6/b0/e6275aac026ce5d626c1e6ebb1fde9b0.png?wh=1494x480" alt="图片"></p><h2 id="模型训练" tabindex="-1"><a class="header-anchor" href="#模型训练"><span>模型训练</span></a></h2><p>好啦，数据准备就绪，我们现在进入模型训练阶段。</p><p>今天我想向你介绍一个在最近 2 年非常受欢迎的一个网络——EfficientNet。它为我们提供了 B0 ～ B7，一共 8 个不同版本的模型，这 8 个版本有着不同的参数量，在同等参数量的模型中，它的精度都是首屈一指的。因此，这 8 个版本的模型可以解决你的大多数问题。</p><h3 id="efficientnet" tabindex="-1"><a class="header-anchor" href="#efficientnet"><span>EfficientNet</span></a></h3><p>我先给你解读一下<a href="https://arxiv.org/pdf/1905.11946.pdf" target="_blank" rel="noopener noreferrer">EfficientNet</a>的这篇论文，这里我着重分享论文的核心思路还有我的理解，学有余力的同学可以在课后自行阅读原文。</p><p>EfficientNet 一共有 B0 到 B7，8 个模型，参数量由少到多，精度也越来越高，具体你可以看看后面的评价指标。</p><p>在之前的那些网络，要么从网络的深度出发，要么从网络的宽度出发来优化网络的性能，但从来没有人将这些方向结合在一起考虑。<strong>而 EfficientNet 就做了这样的尝试，它探索了网络深度、网络宽度、图像分辨率之间的最优组合</strong>。</p><p>EfficientNet 利用一种复合的缩放手段，对网络的深度 depth、宽度 width 和分辨率 resolution 同时进行缩放（按照一定的缩放规律），来达到精度和运算复杂度 FLOPS 的权衡。</p><p>但即使只探索这三个维度，搜索空间仍然很大，所以作者规定只在 B0（作者提出的 EfficientNet 的一个 Baseline）上进行放大。</p><p>首先，作者比较了单独放大这三个维度中的任意一个维度效果如何。得出结论是放大网络深度或网络宽度或图像分辨率，均可提升模型精度，但是越放大，精度增加越缓慢，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/7f/64/7ff4750599323623bb148ed8b2222b64.png?wh=1920x591" alt="图片"></p><p>然后，作者做了第二个实验，尝试在不同的 r（分辨率），d（深度）组合下变动 w（宽度），得到下图：</p><p><img src="https://static001.geekbang.org/resource/image/de/46/dec67f3868ddcc44e503yy13a09c1e46.png?wh=1734x1310" alt="图片"></p><p>结论是，得到更高的精度以及效率的关键是平衡网络宽度，网络深度，图像分辨率三个维度的缩放倍率(d, r, w)。</p><p>因此，作者提出了混合维度放大法，该方法使用一个$\\phi$（混合稀疏）来决定三个维度的放大倍率。</p><p>深度 depth：$d = \\alpha ^{\\phi}$</p><p>宽度 width：$w = \\beta ^{\\phi}$</p><p>分辨率 resolution: $r = \\gamma ^{\\phi}$</p><p>$$s.t. \\space \\alpha\\cdot\\beta^2\\cdot\\gamma^2 \\approx2 \\space \\space \\alpha \\geq1,\\beta \\geq1,\\gamma \\geq1$$</p><p>第一步，固定$\\phi$为 1，也就是计算量为 2 倍，使用网格搜索，得到了最佳的组合，也就是$\\alpha=1.2, \\beta = 1.1, \\gamma = 1.15$。</p><p>第二步，固定$\\alpha=1.2, \\beta = 1.1, \\gamma = 1.15$，使用不同的混合稀疏$\\phi$，得到了 B1~B7。</p><p>整体评估效果如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/03/14/037cd03be0995f97caa71ba079078814.png?wh=1682x1324" alt="图片"></p><p>从评估结果上可以看到，EfficientNet 的各个版本均超过了之前的一些经典卷积神经网络。</p><p>EfficientNet v2 也已经被提出来了，有时间的话你可以自己去看看。</p><p>我们不妨借助一下 EfficientNet 的<a href="https://github.com/lukemelas/EfficientNet-PyTorch" target="_blank" rel="noopener noreferrer">GitHub</a>，它里面有训练 ImageNet 的 demo(demo/imagenet/main.py)，接下来我们一起看看它的核心代码，然后精简一下代码，把它运行起来(Torchvision 也提供了 EfficientNet 的模型，课后你也可以自己试一试)。</p><p>这里我们再回顾一下，之前说的机器学习 3 件套：</p><p>1.数据处理 2.模型训练（构建模型、损失函数与优化方法） 3.模型评估</p><p>接下来我们就挨个看看这些步骤。你需要先把<a href="https://github.com/lukemelas/EfficientNet-PyTorch" target="_blank" rel="noopener noreferrer">https://github.com/lukemelas/EfficientNet-PyTorch</a>给克隆下来，我们只使用 efficientnet_pytorch 中的内容，它包含着模型的网络结构。</p><p>之后我们来创建一个叫做 geektime 的项目文件夹，然后把 efficientnet_pytorch 放进去。</p><p>在开始之前，我先把程序需要的参数给你列一下，在下面的讲解中，我们就直接使用这些参数了。当你在实现今天代码的时候，需要将这些参数补充到代码中（可以使用 argparsem 模块）。</p><p><img src="https://static001.geekbang.org/resource/image/df/7a/df24d6aa865b645f1d2aa50716e7d17a.jpg?wh=1739x1027" alt="图片"></p><p>好，下面让我们正式开始动手。</p><h3 id="加载数据" tabindex="-1"><a class="header-anchor" href="#加载数据"><span>加载数据</span></a></h3><p>首先是数据加载的环节，我们创建一个 dataset.py 文件，用来存储与数据有关的内容。dataset.py 如下（我省略了模块的引入）。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"></span>
<span class="line"><span class="token comment"># 作者给出的标准化方法</span></span>
<span class="line"><span class="token keyword">def</span> <span class="token function">_norm_advprop</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token keyword">return</span> img <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">def</span> <span class="token function">build_transform</span><span class="token punctuation">(</span>dest_image_size<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    normalize <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Lambda<span class="token punctuation">(</span>_norm_advprop<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>dest_image_size<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">        dest_image_size <span class="token operator">=</span> <span class="token punctuation">(</span>dest_image_size<span class="token punctuation">,</span> dest_image_size<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">        dest_image_size <span class="token operator">=</span> dest_image_size</span>
<span class="line"></span>
<span class="line">    transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span></span>
<span class="line">        transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span>dest_image_size<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        normalize</span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> transform</span>
<span class="line"></span>
<span class="line"><span class="token keyword">def</span> <span class="token function">build_data_set</span><span class="token punctuation">(</span>dest_image_size<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    transform <span class="token operator">=</span> build_transform<span class="token punctuation">(</span>dest_image_size<span class="token punctuation">)</span> </span>
<span class="line">    dataset<span class="token operator">=</span>datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>data<span class="token punctuation">,</span> transform<span class="token operator">=</span>transform<span class="token punctuation">,</span> target_transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span> </span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> dataset</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这部分代码完成的工作是，通过 build_data_set 构建数据集。这里我们使用了 torchvision.datasets.ImageFolder 来创建 Dataset。ImageFolder 能将按文件夹形式的组织数据生成到一个 Dataset。</p><p>在这个例子中，我传入的训练集路径为&#39;./data/train&#39;，你可以看看开篇的截图。</p><p>ImageFolder 会自动的将同一文件夹内的数据打上一个标签，也就是说 logo 文件夹的数据，ImageFolder 会认为是来自同一类别，others 文件夹的数据，ImageFolder 会认为是来自另外一个类别。</p><p>我们这个精简版只构建了训练集的 Dataset，当你看 Efficient 官方代码的时候，在验证集的构建过程中，你需要留意一下验证集的<a href="https://github.com/lukemelas/EfficientNet-PyTorch/blob/master/examples/imagenet/main.py#L240-L245" target="_blank" rel="noopener noreferrer">transforms</a>。</p><p>我认为，这里这么做是有点问题的，原因是 Resize 中 size 参数如果是个 tuple 类型，则直接按照 size 的尺寸进行 resize。如果是一个 int 的时候，如果图片的 height 大于 width，则按照(size * height/width, size)进行 resize。</p><p>在作者的原始程序中，imag_size 是个 int，而不是 tuple。所以按照这种先 resize 再 crop 的方式处理一下，对长宽比比较大的图片来说，效果不是很好。</p><p>让我们实际验证一下这个想法，我将开篇的例子（也就是那张海报图）的 image_size 设定为 224 后，用上述的方式进行处理后，获得下图。</p><p><img src="https://static001.geekbang.org/resource/image/a9/e2/a93417ee476234249d0e69fb5c5f04e2.jpg?wh=224x224" alt="图片"></p><p>你看，是不是缺少了很多信息？</p><p>所以，如果在我们的例子中使用作者的程序，就需要做一下修改。把这里的代码逻辑修改为如果 image_size 不是 tuple，先将 image_size 转换为 tuple，并且也不需要 crop 了。代码如下所示：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>image_size<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    image_size <span class="token operator">=</span> <span class="token punctuation">(</span>image_size<span class="token punctuation">,</span> image_size<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">    image_size <span class="token operator">=</span> image_size</span>
<span class="line"></span>
<span class="line">transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span></span>
<span class="line">    transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span>image_size<span class="token punctuation">,</span> interpolation<span class="token operator">=</span>Image<span class="token punctuation">.</span>BICUBIC<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    normalize<span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>训练的主程序我们定义在 main.py 中，在 main.py 中的 main()中，进行数据的加载，如下所示。</p><p>然后，我们通过 for 循环一个一个 Epoch 的调用 train 方法进行训练就可以了。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token comment"># 省略了一些模块的引入</span></span>
<span class="line"><span class="token keyword">from</span> efficientnet <span class="token keyword">import</span> EfficientNet</span>
<span class="line"><span class="token keyword">from</span> dataset <span class="token keyword">import</span> build_data_set</span>
<span class="line"></span>
<span class="line"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token comment"># part1: 模型加载 (稍后补充)</span></span>
<span class="line">    <span class="token comment"># part2: 损失函数、优化方法(稍后补充)   </span></span>
<span class="line">    train_dataset <span class="token operator">=</span> build_data_set<span class="token punctuation">(</span>args<span class="token punctuation">.</span>image_size<span class="token punctuation">,</span> args<span class="token punctuation">.</span>train_data<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span></span>
<span class="line">        train_dataset<span class="token punctuation">,</span> </span>
<span class="line">        batch_size<span class="token operator">=</span>args<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span></span>
<span class="line">        shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span></span>
<span class="line">        num_workers<span class="token operator">=</span>args<span class="token punctuation">.</span>workers<span class="token punctuation">,</span></span>
<span class="line">        <span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token comment"># 调用train函数进行训练，稍后补充</span></span>
<span class="line">        train<span class="token punctuation">(</span>train_loader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> criterion<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> epoch<span class="token punctuation">,</span> args<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment"># 模型保存        </span></span>
<span class="line">        <span class="token keyword">if</span> epoch <span class="token operator">%</span> args<span class="token punctuation">.</span>save_interval <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>args<span class="token punctuation">.</span>checkpoint_dir<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">                os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>args<span class="token punctuation">.</span>checkpoint_dir<span class="token punctuation">)</span></span>
<span class="line">            torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>args<span class="token punctuation">.</span>checkpoint_dir<span class="token punctuation">,</span></span>
<span class="line">                    <span class="token string">&#39;checkpoint.pth.tar.epoch_%s&#39;</span> <span class="token operator">%</span> epoch<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创建模型" tabindex="-1"><a class="header-anchor" href="#创建模型"><span>创建模型</span></a></h3><p>接下来，我们来看看如何创建模型，这一步我们直接使用作者给出的 Efficient 模型。在上面代码注释中的 part1 部分，用下述代码即可加载 EfficientNet 模型。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line">    args<span class="token punctuation">.</span>classes_num <span class="token operator">=</span> <span class="token number">2</span></span>
<span class="line">    <span class="token keyword">if</span> args<span class="token punctuation">.</span>pretrained<span class="token punctuation">:</span></span>
<span class="line">        model <span class="token operator">=</span> EfficientNet<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>args<span class="token punctuation">.</span>arch<span class="token punctuation">,</span> num_classes<span class="token operator">=</span>args<span class="token punctuation">.</span>classes_num<span class="token punctuation">,</span></span>
<span class="line">                advprop<span class="token operator">=</span>args<span class="token punctuation">.</span>advprop<span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;=&gt; using pre-trained model &#39;{}&#39;&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>arch<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;=&gt; creating model &#39;{}&#39;&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>arch<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">        model <span class="token operator">=</span> EfficientNet<span class="token punctuation">.</span>from_name<span class="token punctuation">(</span>args<span class="token punctuation">.</span>arch<span class="token punctuation">,</span> override_params<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&#39;num_classes&#39;</span><span class="token punctuation">:</span> args<span class="token punctuation">.</span>classes_num<span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment"># 有GPU的话，加上cuda()</span></span>
<span class="line">    <span class="token comment">#mode.cuda()</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是说，如果 pretrained model 参数为 True，则自动下载并加载 pretrained model 后进行训练，否则是使用随机数初始化网络。 from_pretrained 与 from_name 中，都需要修改一下 num_classes，将 EfficientNet 的全连接层修改我们项目对应的类别数，这里的 args.classes_num 为 2（logo 类与 others 类）。</p><h4 id="模型微调" tabindex="-1"><a class="header-anchor" href="#模型微调"><span>模型微调</span></a></h4><p>模型微调在[第 8 节课]和[第 14 节课]时说过，这个概念比较重要，我们一起再复习一下。</p><p>Pretrained model 一般是在 ImageNet（也有可能是 COCO 或 VOC，都是公开数据集）上训练过的模型，我们可以直接把它在 ImageNet 上训练好的模型参数直接拿过来，在其基础上训练我们自己的模型，这就是模型微调。</p><p>所以说，<strong>如果有 Pretrained model，我们一定会使用 Pretrained model 进行训练，收敛速度会快</strong>。</p><p>使用 Pretrained model 的时候要注意一点，在 ImageNet 上训练后的全连接层一共有 1000 个节点，所以使用 Pretrained model 的时候只使用全连接层以外的参数。</p><p>在上述代码的 EfficientNet.from_pretrained 中，会<s>通</s>调用 load_pretrained_weights 函数，调用之前 num_classes 已经被修改为 2（logo 与 others），所以说传入 load_pretrained_weights 的 load_fc 参数为 False，也就是说不会加载全连接层的参数。load_pretrained_weights 的调用如下所示：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line">load_pretrained_weights<span class="token punctuation">(</span>model<span class="token punctuation">,</span> model_name<span class="token punctuation">,</span> load_fc<span class="token operator">=</span><span class="token punctuation">(</span>num_classes <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> advprop<span class="token operator">=</span>advprop<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>load_pretrained_weights 函数中包含下面这段代码，就像刚才所说，如果不加载全连接层，则删除_fc 的 weight 与 bias：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">if</span> load_fc<span class="token punctuation">:</span></span>
<span class="line">    ret <span class="token operator">=</span> model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>state_dict<span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">assert</span> <span class="token keyword">not</span> ret<span class="token punctuation">.</span>missing_keys<span class="token punctuation">,</span> <span class="token string">&#39;Missing keys when loading pretrained weights: {}&#39;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>missing_keys<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">    state_dict<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">&#39;_fc.weight&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    state_dict<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">&#39;_fc.bias&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    ret <span class="token operator">=</span> model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>state_dict<span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="设定损失函数与优化方法" tabindex="-1"><a class="header-anchor" href="#设定损失函数与优化方法"><span>设定损失函数与优化方法</span></a></h3><p>最后要做的就是设定损失函数与优化方法了，我们将下面的代码补充到 part2 部分：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line">criterion <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 有GPU的话加上.cuda()</span></span>
<span class="line"></span>
<span class="line">optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>lr<span class="token punctuation">,</span></span>
<span class="line">                            momentum<span class="token operator">=</span>args<span class="token punctuation">.</span>momentum<span class="token punctuation">,</span></span>
<span class="line">                            weight_decay<span class="token operator">=</span>args<span class="token punctuation">.</span>weight_decay<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，我们就完成训练的所有准备了，只要再补充好 train 函数就可以了，代码如下。下面的代码的原理我们在[第 13 节课]中已经讲过了，记不清的可以去回顾一下。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>train_loader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> criterion<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> epoch<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token comment"># switch to train mode</span></span>
<span class="line">    model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>images<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>train_loader<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token comment"># compute output</span></span>
<span class="line">        output <span class="token operator">=</span> model<span class="token punctuation">(</span>images<span class="token punctuation">)</span></span>
<span class="line">        loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;Epoch &#39;</span><span class="token punctuation">,</span> epoch<span class="token punctuation">,</span> loss<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment"># compute gradient and do SGD step</span></span>
<span class="line">        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过在我的程序里，保存了若干个 Epoch 的模型，我们应该怎么选择呢？这就要说到模型的评估环节。</p><h2 id="模型评估" tabindex="-1"><a class="header-anchor" href="#模型评估"><span>模型评估</span></a></h2><p>对于分类模型的评估来说，有很多评价指标，例如准确率、精确率、召回率、F1-Score 等。其中，<strong>我认为最直观、最有说服力的就是精确率与召回率</strong>，这也是我在项目中观察的主要是指标。下面我们依次来看看。</p><h3 id="混淆矩阵" tabindex="-1"><a class="header-anchor" href="#混淆矩阵"><span>混淆矩阵</span></a></h3><p>在讲解精确率与召回率之前，我们先看看混淆矩阵这个概念。其实精确率与召回率就是通过它计算出来的。下表就是一个混淆矩阵，正例就是 logo 类，负例就是 others 类。</p><p><img src="https://static001.geekbang.org/resource/image/57/8b/5756d1fe45493d69ayy534da3d20088b.jpg?wh=1920x847" alt="图片"></p><p>根据预测结果和真实类别的组合，一共有四种情况：</p><p>1.TP 是说真实类别为 Logo，模型也预测为 Logo； 2.FP 是说真实类别为 Others，但模型预测为 Logo； 3.FN 是说真实类别为 Logo，但模型预测为 Others； 4.TN 是说真实类别为 Others，模型也预测为 Others；</p><p>精确率的计算方法为：</p><p>$$precision = \\frac{TP}{ (TP + FP)}$$</p><p>召回率的计算方式为：</p><p>$$recall = \\frac{TP}{(TP + FN)}$$</p><p>精确率与召回率分别衡量了模型的不同表现，精确率说的是，如果模型认为一张图片是 Logo 类，那有多大概率是 Logo 类。而召回率衡量的是，在整个验证集中，模型能找到多少 Logo 图片。</p><p>那问题来了，怎样根据这两个指标来选择模型呢？业务需求不同，我们侧重的指标就不一样。</p><p>比如在我们的这个项目中，如果老板允许一部分 Logo 图片没有被识别，但是模型必须非常准，模型说一张图片是 Logo 类，那图片真实类别就有非常大的概率是 Logo 类图片，那应该侧重的就是精确率；如果老板希望把线上 Logo 类尽可能地识别出来，允许一部分图片被误识别，那应该侧重的就是召回率。</p><p>在计算精确率与召回率的时候，给你分享一下我的经验。在实际项目中，我习惯把模型对每张图片的预测结果保存到一个 txt 中，这样可以比较直观地筛选一些模型的 badcase，并且验证集如果非常大，又需要调整的时候，直接更改 txt 就可以了，不需要再次让模型预测整个验证集。</p><p>下面是 txt 文件的一部分，分别记录了 logo 类的概率、others 类的概率、真实类别是否为 logo、真实类别是否为 others、预测类别是否为 logo、预测类别是否为 ohters、图片名。</p><p>14.jpeg 是开篇例子的那张图片，模型认为它是 Logo 的概率是 0.58476，others 类的概率是 0.41524。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token number">0.64460</span> <span class="token number">0.35540</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token operator">/</span>data<span class="token operator">/</span>val<span class="token operator">/</span>logo<span class="token operator">/</span><span class="token number">13</span><span class="token punctuation">.</span>jpeg</span>
<span class="line"><span class="token number">0.58476</span> <span class="token number">0.41524</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token operator">/</span>data<span class="token operator">/</span>val<span class="token operator">/</span>logo<span class="token operator">/</span><span class="token number">14</span><span class="token punctuation">.</span>jpeg</span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是我训练了 10 个 Epoch 的 B0 模型，在验证集(这里我用训练集充当了一下验证集)上的评价效果。 <img src="https://static001.geekbang.org/resource/image/95/00/95a4b9f3e9eddb32b3bc30e85dfa2500.png?wh=966x730" alt="图片"></p><p>通过混淆矩阵可以看到，整个验证集一共有 8+0 张图片被预测为 logo 类，所以 logo 类的精确率为 8 / (8 + 0 ) = 1；logo 类一共有 8+2 张图片，有两张预测错了，所以召回率为 8 / (8 +2) = 0.8。</p><p>others 类别的计算类似，你可以自己算算看。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>恭喜你，完成了今天的学习任务。今天我们一起完成了一个图像分类项目的实践。虽然项目规模较小，但是在真实项目中的每一个环节都包含在内了，可以说是麻雀虽小，五脏俱全。</p><p>下面我们回顾一下每个环节上的关键要点和实操经验。</p><p><strong>数据准备其实是最关键的一步，数据的质量直接决定了模型好坏</strong>。所以，在开始训练之前你应该对你的数据集有十足的了解才可以。例如，验证集还是否可以反映出训练集、数据中有没有脏数据、数据分布有没有偏等等。</p><p>完成数据准备之后就到了模型训练，图像分类任务其实基本上都是采用主流的卷积神经网络了，很少对模型结构做一些更改。</p><p>最后的模型评估环节要侧重业务场景，看业务上需要高精确还是高召回，然后再对你的模型做调整。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>老板希望你的模型能尽可能的把线上所有极客时间的海报都找到，允许一些误召回。训练模型的时候你应该侧重精确率还是召回率？</p><p>推荐你动手实现一下今天的 Demo，也欢迎你把这节课分享给更多的同事、朋友，跟他一起学习进步。</p>`,115)]))}const l=s(t,[["render",i]]),u=JSON.parse('{"path":"/3.tech/83.PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/18_%E5%AE%9E%E6%88%98%E7%AF%87-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B.html","title":"实战篇-图像分类（下）：如何构建一个图像分类模型","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"问题回顾","slug":"问题回顾","link":"#问题回顾","children":[]},{"level":2,"title":"数据准备","slug":"数据准备","link":"#数据准备","children":[]},{"level":2,"title":"模型训练","slug":"模型训练","link":"#模型训练","children":[{"level":3,"title":"EfficientNet","slug":"efficientnet","link":"#efficientnet","children":[]},{"level":3,"title":"加载数据","slug":"加载数据","link":"#加载数据","children":[]},{"level":3,"title":"创建模型","slug":"创建模型","link":"#创建模型","children":[]},{"level":3,"title":"设定损失函数与优化方法","slug":"设定损失函数与优化方法","link":"#设定损失函数与优化方法","children":[]}]},{"level":2,"title":"模型评估","slug":"模型评估","link":"#模型评估","children":[{"level":3,"title":"混淆矩阵","slug":"混淆矩阵","link":"#混淆矩阵","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]},{"level":2,"title":"思考题","slug":"思考题","link":"#思考题","children":[]}],"git":{"updatedTime":1746672966000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":3,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"873191059aa4709eddd6184a409223b5054edb2a","time":1746672966000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: pytorch fixed"},{"hash":"f2ddff143d5e7042818e92930c2e210f4b633ca8","time":1746603363000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: 250507 bugfix"},{"hash":"b44b80ec6b8c2ebffa55c7b2b54259609c76baed","time":1745668690000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"add pytorch course"}]},"filePathRelative":"3.tech/83.PyTorch深度学习实战/18_实战篇-图像分类（下）：如何构建一个图像分类模型.md"}');export{l as comp,u as data};
