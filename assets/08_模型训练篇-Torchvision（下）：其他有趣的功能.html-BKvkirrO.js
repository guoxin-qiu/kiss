import{_ as s,c as a,b as e,o as p}from"./app-C01vnHKY.js";const o={};function i(t,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="模型训练篇-torchvision-下-其他有趣的功能" tabindex="-1"><a class="header-anchor" href="#模型训练篇-torchvision-下-其他有趣的功能"><span>模型训练篇 Torchvision（下）：其他有趣的功能</span></a></h1><p>在前面的课程中，我们已经学习了 Torchvision 的数据读取与常用的图像变换方法。其实，Torchvision 除了帮我们封装好了常用的数据集，还为我们提供了深度学习中各种经典的网络结构以及训练好的模型，只要直接将这些经典模型的类实例化出来，就可以进行训练或使用了。</p><p>我们可以利用这些训练好的模型来实现图片分类、物体检测、视频分类等一系列应用。</p><p>今天，我们就来学习一下经典网络模型的实例化与 Torchvision 中其他有趣的功能。</p><h2 id="常见网络模型" tabindex="-1"><a class="header-anchor" href="#常见网络模型"><span>常见网络模型</span></a></h2><p>Torchvision 中的各种经典网络结构以及训练好的模型，都放在了<code>torchvision.models</code>模块中，下面我们来看一看<code>torchvision.models</code> 具体为我们提供了什么支持，以及这些功能如何使用。</p><h3 id="torchvision-models-模块" tabindex="-1"><a class="header-anchor" href="#torchvision-models-模块"><span>torchvision.models 模块</span></a></h3><p><code>torchvision.models</code> 模块中包含了常见网络模型结构的定义，这些网络模型可以解决以下四大类问题：图像分类、图像分割、物体检测和视频分类。图像分类、物体检测与图像分割的示意图如下图所示。</p><p><img src="https://static001.geekbang.org/resource/image/42/b3/4211c2d8cd27db3e903e6125122f47b3.jpg?wh=1920x1204" alt=""></p><p>图像分类，指的是单纯把一张图片判断为某一类，例如将上图左侧第一张判断为 cat。目标检测则是说，首先检测出物体的位置，还要识别出对应物体的类别。如上图中间的那张图，不仅仅要找到猫、鸭子、狗的位置，还有给出给定物体的类别信息。</p><p>我们看一下图里最右侧的例子，它表示的是分割。分割即是对图像中每一个像素点进行分类，确定每个点的类别，从而进行区域划分。</p><p>在早期的 Torchvision 版本中，<code>torchvision.models</code>模块中只包含了图片分类中的一部分网络，例如 AlexNet、VGG 系列、ResNet 系列、Inception 系列等。这里你先有个印象就行，具体网络特点，我后面会在图像分类中详细讲解。</p><p>到了现在，随着深度学习技术的不断发展，人工智能应用更为广泛，<code>torchvision.models</code>模块中所封装的网络模型也在不断丰富。比如在当前版本（v0.10.0）的 Torchvision 中，新增了图像语义分割、物体检测和视频分类的相关网络，并且在图像分类中也新增了 GoogLeNet、ShuffleNet 以及可以使用于移动端的 MobileNet 系列。这些新模型，都能让我们站在巨人的肩膀上看世界。</p><h3 id="实例化一个-googlenet-网络" tabindex="-1"><a class="header-anchor" href="#实例化一个-googlenet-网络"><span>实例化一个 GoogLeNet 网络</span></a></h3><p>如果我们直接把一个网络模型的类实例化，就会得到一个网络模型。而这个网络模型的类可以是我们自己定义的结构，也可以是按照经典模型的论文设计出来的结构。其实你自己按照经典模型的论文写一个类，然后实例化一下，这和从 Torchvision 中直接实例化一个网络效果是相同的。</p><p>下面我们就以 GoogLeNet 网络为例，来说说如何使用<code>torchvision.models</code>模块实例化一个网络。</p><p>GoogLeNet 是 Google 推出的基于 Inception 模块的深度神经网络模型。你可别小看这个模型，GoogLeNet 获得了 2014 年的 ImageNet 竞赛的冠军，并且相比之前的 AlexNet、VGG 等结构能更高效地利用计算资源。</p><p>GoogLeNet 也被称为 Inception V1，在随后的两年中它一直在改进，形成了 Inception V2、Inception V3 等多个版本。</p><p>我们可以使用<strong>随机初始化的权重，创建一个 GoogLeNet 模型</strong>，具体代码如下：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">as</span> models</span>
<span class="line">googlenet <span class="token operator">=</span> models<span class="token punctuation">.</span>googlenet<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候的 GoogLeNet 模型，相当于只有一个实例化好的网络结构，里面的参数都是随机初始化的，需要经过训练之后才能使用，并不能直接用于预测。 <code>torchvision.models</code>模块除了包含了定义好的网络结构，还为我们提供了预训练好的模型，我们可以<strong>直接导入训练好的模型来使用</strong>。导入预训练好的模型的代码如下：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">as</span> models</span>
<span class="line">googlenet <span class="token operator">=</span> models<span class="token punctuation">.</span>googlenet<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，我们只是在实例化的时候，引入了一个参数“pretrained=True”，即可获得预训练好的模型，因为所有的工作<code>torchvision.models</code>模块都已经帮我们封装好了，用起来很方便。 <code>torchvision.models</code>模块中所有预训练好的模型，都是在 ImageNet 数据集上训练的，它们都是由 PyTorch 的<code>torch.utils.model_zoo</code>模块所提供的，并且我们可以通过参数  pretrained=True  来构造这些预训练模型。</p><p>如果之前没有加载过带预训练参数的网络，在实例化一个预训练好的模型时，模型的参数会被下载至缓存目录中，下载一次后不需要重复下载。这个缓存目录可以通过环境变量 TORCH_MODEL_ZOO 来指定。当然，你也可以把自己下载好的模型，然后复制到指定路径中。</p><p>下图是运行了上述实例化代码的结果，可以看到，GoogLeNet 的模型参数被下载到了缓存目录/root/.cache/torch 下面。</p><p><img src="https://static001.geekbang.org/resource/image/16/49/16975c6f4071ee1dacc9a41a28f93c49.png?wh=1920x270" alt="图片"></p><p><code>torchvision.models</code>模块也包含了 Inception V3 和其他常见的网络结构，在实例化时，只需要修改网络的类名，即可做到举一反三。<code>torchvision.models</code>模块中可实例化的全部模型详见这个<a href="https://pytorch.org/vision/stable/models.html" target="_blank" rel="noopener noreferrer">网页</a>。</p><h3 id="模型微调" tabindex="-1"><a class="header-anchor" href="#模型微调"><span>模型微调</span></a></h3><p>完成了刚才的工作，你可能会疑惑，实例化了带预训练参数的网络有什么用呢？其实它除了可以直接用来做预测使用，还可以基于它做网络模型的微调，也就是“fine-tuning”。</p><p>那什么是“fine-tuning”呢？</p><p>举个例子，假设你的老板给布置了一个有关于图片分类的任务，数据集是关于狗狗的图片，让你区分图片中狗的种类，例如金毛、柯基、边牧等等。</p><p>问题是数据集中狗的类别很多，但数据却不多。你发现从零开始训练一个图片分类模型，但这样模型效果很差，并且很容易过拟合。这种问题该如何解决呢？于是你想到了使用迁移学习，可以用已经在 ImageNet 数据集上训练好的模型来达成你的目的。</p><p>例如上面我们已经实例化的 GoogLeNet 模型，只需要使用我们自己的数据集，重新训练网络最后的分类层，即可得到区分狗种类的图片分类模型。这就是所谓的“fine-tuning”方法。</p><p><strong>模型微调</strong>，简单来说就是先在一个比较通用、宽泛的数据集上进行大量训练得出了一套参数，然后再使用这套预训练好的网络和参数，在自己的任务和数据集上进行训练。使用经过预训练的模型，要比使用随机初始化的模型训练<strong>效果更好</strong>，<strong>更容易收敛</strong>，并且<strong>训练速度更快</strong>，在小数据集上也能取得比较理想的效果。</p><p>那新的问题又来了，为什么模型微调如此有效呢？因为我们相信同样是处理图片分类任务的两个模型，网络的参数也具有某种相似性。因此，把一个已经训练得很好的模型参数迁移到另一个模型上，同样有效。即使两个模型的工作不完全相同，我们也可以在这套预训练参数的基础上，经过微调性质的训练，同样能取得不错的效果。</p><p>ImageNet 数据集共有 1000 个类别，而狗的种类远远达不到 1000 类。因此，加载了预训练好的模型之后，还需要根据你的具体问题对模型或数据进行一些调整，通常来说是调整输出类别的数量。</p><p>假设狗的种类一共为 10 类，那么我们自然需要将 GoogLeNet 模型的输出分类数也调整为 10。对预训练模型进行调整对代码如下：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">import</span> torch</span>
<span class="line"><span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>models <span class="token keyword">as</span> models</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 加载预训练模型</span></span>
<span class="line">googlenet <span class="token operator">=</span> models<span class="token punctuation">.</span>googlenet<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 提取分类层的输入参数</span></span>
<span class="line">fc_in_features <span class="token operator">=</span> googlenet<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>in_features</span>
<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;fc_in_features:&quot;</span><span class="token punctuation">,</span> fc_in_features<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 查看分类层的输出参数</span></span>
<span class="line">fc_out_features <span class="token operator">=</span> googlenet<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>out_features</span>
<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;fc_out_features:&quot;</span><span class="token punctuation">,</span> fc_out_features<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 修改预训练模型的输出分类数(在图像分类原理中会具体介绍torch.nn.Linear)</span></span>
<span class="line">googlenet<span class="token punctuation">.</span>fc <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>fc_in_features<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token triple-quoted-string string">&#39;&#39;&#39;</span>
<span class="line">输出：</span>
<span class="line">fc_in_features: 1024</span>
<span class="line">fc_out_features: 1000</span>
<span class="line">&#39;&#39;&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，你需要加载预训练模型，然后提取预训练模型的分类层固定参数，最后修改预训练模型的输出分类数为 10。根据输出结果，我们可以看到预训练模型的原始输出分类数是 1000。</p><h2 id="其他常用函数" tabindex="-1"><a class="header-anchor" href="#其他常用函数"><span>其他常用函数</span></a></h2><p>之前在<code>torchvision.transforms</code>中，我们学习了很多有关于图像处理的函数，Torchvision 还提供了几个常用的函数，make_grid 和 save_img，让我们依次来看一看它们又能实现哪些有趣的功能。</p><h3 id="make-grid" tabindex="-1"><a class="header-anchor" href="#make-grid"><span>make_grid</span></a></h3><p>make_grid 的作用是将若干幅图像拼成在一个网格中，它的定义如下。</p><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain"><pre><code><span class="line">torchvision.utils.make_grid(tensor, nrow=8, padding=2) </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>定义中对应的几个参数含义如下：</p><ul><li>tensor：类型是 Tensor 或列表，如果输入类型是 Tensor，其形状应是 (B x C x H x W)；如果输入类型是列表，列表中元素应为相同大小的图片。</li><li>nrow：表示一行放入的图片数量，默认为 8。</li><li>padding：子图像与子图像之间的边框宽度，默认为 2 像素。</li></ul><p>make_grid 函数主要用于展示数据集或模型输出的图像结果。我们以 MNIST 数据集为例，整合之前学习过的读取数据集以及图像变换的内容，来看一看 make_grid 函数的效果。</p><p>下面的程序利用 make_grid 函数，展示了 MNIST 的测试集中的 32 张图片。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">import</span> torchvision</span>
<span class="line"><span class="token keyword">from</span> torchvision <span class="token keyword">import</span> datasets</span>
<span class="line"><span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms</span>
<span class="line"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 加载MNIST数据集</span></span>
<span class="line">mnist_dataset <span class="token operator">=</span> datasets<span class="token punctuation">.</span>MNIST<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">&#39;./data&#39;</span><span class="token punctuation">,</span></span>
<span class="line">                               train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span></span>
<span class="line">                               transform<span class="token operator">=</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">                               target_transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span></span>
<span class="line">                               download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment"># 取32张图片的tensor</span></span>
<span class="line">tensor_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>mnist_dataset<span class="token punctuation">,</span></span>
<span class="line">                               batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span></span>
<span class="line">data_iter <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>tensor_dataloader<span class="token punctuation">)</span></span>
<span class="line">img_tensor<span class="token punctuation">,</span> label_tensor <span class="token operator">=</span> data_iter<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span>img_tensor<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></span>
<span class="line"><span class="token triple-quoted-string string">&#39;&#39;&#39;</span>
<span class="line">输出：torch.Size([32, 1, 28, 28])</span>
<span class="line">&#39;&#39;&#39;</span></span>
<span class="line"><span class="token comment"># 将32张图片拼接在一个网格中</span></span>
<span class="line">grid_tensor <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>img_tensor<span class="token punctuation">,</span> nrow<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line">grid_img <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToPILImage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>grid_tensor<span class="token punctuation">)</span></span>
<span class="line">display<span class="token punctuation">(</span>grid_img<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合代码我们可以看到，程序首先利用<code>torchvision.datasets</code>加载 MNIST 的测试集，然后利用 DataLoader 类的迭代器一次获取到 32 张图片的 Tensor，最后利用 make_grid 函数将 32 张图片拼接在了一幅图片中。 MNIST 的测试集中的 32 张图片，如下图所示，这里我要特别说明一下，因为 MNIST 的尺寸为 28x28，所以测试集里的手写数字图片像素都比较低，但这并不影响咱们动手实践。你可以参照我给到的示范，自己动手试试看。</p><p><img src="https://static001.geekbang.org/resource/image/bb/yy/bb73d6bdf49fc876d983cfa48569dcyy.png?wh=242x122" alt="图片"></p><h3 id="save-img" tabindex="-1"><a class="header-anchor" href="#save-img"><span>save_img</span></a></h3><p>一般来说，在保存模型输出的图片时，需要将 Tensor 类型的数据转化为图片类型才能进行保存，过程比较繁琐。Torchvision 提供了 save_image 函数，能够直接将 Tensor 保存为图片，即使 Tensor 数据在 CUDA 上，也会自动移到 CPU 中进行保存。</p><p>save_image 函数的定义如下。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line">torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>save_image<span class="token punctuation">(</span>tensor<span class="token punctuation">,</span> fp<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这些参数也很好理解：</p><ul><li>tensor：类型是 Tensor 或列表，如果输入类型是 Tensor，直接将 Tensor 保存；如果输入类型是列表，则先调用 make_grid 函数生成一张图片的 Tensor，然后再保存。</li><li>fp：保存图片的文件名；</li><li>**kwargs：make_grid 函数中的参数，前面已经讲过了。</li></ul><p>我们接着上面的小例子，将 32 张图片的拼接图直接保存，代码如下。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token comment"># 输入为一张图片的tensor 直接保存</span></span>
<span class="line">torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>save_image<span class="token punctuation">(</span>grid_tensor<span class="token punctuation">,</span> <span class="token string">&#39;grid.jpg&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 输入为List 调用grid_img函数后保存</span></span>
<span class="line">torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>save_image<span class="token punctuation">(</span>img_tensor<span class="token punctuation">,</span> <span class="token string">&#39;grid2.jpg&#39;</span><span class="token punctuation">,</span> nrow<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当输入为一张图片的 Tensor 时，直接保存，保存的图片如下所示。</p><p><img src="https://static001.geekbang.org/resource/image/bb/yy/bb73d6bdf49fc876d983cfa48569dcyy.png?wh=242x122" alt="图片"></p><p>当输入为 List 时，则会先调用 make_grid 函数，make_grid 函数的参数直接加在后面即可，代码中令 nrow=5，保存的图片如下所示。这时我们可以看到图片中，每行中有 5 个数字，最后一行不足的数字，已经自动填充了空图像。</p><p><img src="https://static001.geekbang.org/resource/image/21/a6/21435a2115ca4704bc51496f8a1c8da6.png?wh=152x212" alt="图片"></p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>恭喜你完成了这节课的学习。至此，Torchvision 的全部内容我们就学完了。</p><p>今天的重点内容是<code>torchvision.models</code>模块的使用，包括如何实例化一个网络与如何进行模型的微调。</p><p><code>torchvision.models</code>模块为我们提供了深度学习中各种经典的网络结构以及训练好的模型，我们不仅可以实例化一个随机初始化的网络模型，还可以实例化一个预训练好的网络模型。</p><p>模型微调可以让我们在自己的小数据集上快速训练模型，并取得比较理想的效果。但是我们需要根据具体问题对预训练模型或数据进行一些修改，你可以灵活调整输出类别的数量，或者调整输入图像的大小。</p><p>除了模型微调，我还讲了两个 Torchvision 中有趣的函数，make_grid 和 save_img，我还结合之前我们学习过的读取数据集以及图像变换的内容，为你做了演示。相信 Torchvision 工具配合 PyTorch 使用，一定能够使你事半功倍。</p><h2 id="每课一练" tabindex="-1"><a class="header-anchor" href="#每课一练"><span>每课一练</span></a></h2><p>请你使用<code>torchvision.models</code>模块实例化一个 VGG 16 网络。</p><p>欢迎你在留言区跟我交流讨论，也推荐你把这节课分享给更多的同事、朋友。</p><p>我是方远，我们下节课见！</p>`,73)]))}const c=s(o,[["render",i]]),r=JSON.parse('{"path":"/3.tech/83.PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/08_%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%AF%87-Torchvision%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%85%B6%E4%BB%96%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8A%9F%E8%83%BD.html","title":"模型训练篇 Torchvision（下）：其他有趣的功能","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"常见网络模型","slug":"常见网络模型","link":"#常见网络模型","children":[{"level":3,"title":"torchvision.models 模块","slug":"torchvision-models-模块","link":"#torchvision-models-模块","children":[]},{"level":3,"title":"实例化一个 GoogLeNet 网络","slug":"实例化一个-googlenet-网络","link":"#实例化一个-googlenet-网络","children":[]},{"level":3,"title":"模型微调","slug":"模型微调","link":"#模型微调","children":[]}]},{"level":2,"title":"其他常用函数","slug":"其他常用函数","link":"#其他常用函数","children":[{"level":3,"title":"make_grid","slug":"make-grid","link":"#make-grid","children":[]},{"level":3,"title":"save_img","slug":"save-img","link":"#save-img","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]},{"level":2,"title":"每课一练","slug":"每课一练","link":"#每课一练","children":[]}],"git":{"updatedTime":1746672966000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":2,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"873191059aa4709eddd6184a409223b5054edb2a","time":1746672966000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: pytorch fixed"},{"hash":"b44b80ec6b8c2ebffa55c7b2b54259609c76baed","time":1745668690000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"add pytorch course"}]},"filePathRelative":"3.tech/83.PyTorch深度学习实战/08_模型训练篇-Torchvision（下）：其他有趣的功能.md"}');export{c as comp,r as data};
