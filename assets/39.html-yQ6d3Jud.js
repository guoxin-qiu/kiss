import{_ as n,c as a,a as s,o as i}from"./app-Dmwo-0Oh.js";const l={};function r(p,e){return i(),a("div",null,e[0]||(e[0]=[s(`<h1 id="_39-讲-从小作坊到工厂-什么是-seleniumgrid-如何搭建-seleniumgrid" tabindex="-1"><a class="header-anchor" href="#_39-讲-从小作坊到工厂-什么是-seleniumgrid-如何搭建-seleniumgrid"><span>39 讲：从小作坊到工厂：什么是 SeleniumGrid？如何搭建 SeleniumGrid？</span></a></h1><p>你好，我是茹炳晟，今天我分享的主题是“从小作坊到工厂：什么是 Selenium Grid？如何搭建 Selenium Grid？”。</p><p>从今天开始，我们就要一起进入测试基础架构这个新的系列了。我将用四篇文章的篇幅，从 0 到 1，为你深入剖析大型互联网企业的测试基础架构设计，以及其原始驱动力，和你探讨测试执行环境设计、测试报告平台设计以及测试基础架构与 CI/CD 的集成等内容。当然，在这其中还会涉及到很多具有前瞻性的设计创新。</p><p>虽说测试基础架构是资深测试开发人员的必备技能，但此时你可能还并不清楚测试基础架构到底指的是什么？没关系，当你阅读完这个系列的文章之后，相信你一定可以对测试基础架构，以及其关键设计有一个清晰、全面的认识。</p><p>所以，今天我就先和你分享一下，我眼中的测试基础架构到底是指什么？</p><p><strong>什么是测试基础架构？</strong></p><p>测试基础架构指的是，执行测试的过程中用到的所有基础硬件设施以及相关的软件设施。因此，我们也把测试基础架构称之为广义的测试执行环境。通常来讲，测试基础架构主要包括以下内容：</p><ul><li>执行测试的机器；</li><li>测试用例代码仓库；</li><li>发起测试执行的 Jenkins Job；</li><li>统一的测试执行平台；</li><li>测试用例执行过程中依赖的测试服务，比如提供测试数据的统一测试数据平台、提供测试全局配置的配置服务、生成测试报告的服务等；</li><li>…</li></ul><p><strong>由于测试基础架构的核心是围绕测试执行展开的，所以我们今天就先来重点讨论一下“执行测试的机器”部分。</strong></p><p>这部分内容的展开，我会从早期最简单的方法谈起，然后探讨这个方法在实际执行中的弊端，并由此引出我们今天讨论的主角：Selenium Grid。</p><p>先试想一下：你要在一个典型测试场景中，基于某种浏览器去执行 Web 应用的 GUI 测试。这时，你首先要做的就是找到相应的机器，并确保上面已经安装了所需的浏览器。如果这台机器上，还没有安装所需浏览器的话，你需要先安装这个浏览器。一切准备就绪后，你就可以使用这台机器执行测试了。</p><p>如果你要执行的测试只需要覆盖一种浏览器的话，那就很简单了，你只要事先准备好一批专门的机器或者虚拟机，然后安装好所需的浏览器就可以了。同时，如果测试用例的数量也不是很多的话，你需要的这批机器或者虚拟机的数量也不会很多。执行测试时，你只要将需要使用的那台机器的地址提供给测试用例就可以了。</p><p>其实，这种模式就是典型的“小作坊”模式。“小作坊”模式的特点就是，人工维护一批数量不多（通常在 30 台以内）的执行测试的机器，然后按需使用。</p><p>对于小团队来讲，“小作坊”模式的问题并不大。但是，随着测试覆盖率要求的提升，以及测试用例数量的增加，这种“小作坊”模式的弊端就逐渐显现，并被不断放大了。其中，最主要问题体现在以下四个方面：</p><ol><li>当 Web 应用需要进行不同浏览器的兼容性测试时，首先你需要准备很多台机器或者虚拟机，并安装所需的不同浏览器；然后，你要为这些机器建立一个列表，用于记录各台机器安装了什么浏览器；最后，你在执行测试时，需要先查看机器列表以选择合适的测试执行机。</li><li>当 Web 应用需要进行同一浏览器的不同版本的兼容性测试时，你同样需要准备很多安装有同一浏览器的不同版本的测试执行机，并为这些机器建立列表，记录各台机器安装的浏览器版本号，然后执行测试时先查看列表以选择合适的测试执行机。</li><li>测试执行机的机器名或者 IP 发生变化，以及需要新增或者减少测试机时，都需要人工维护这些机器列表。很显然，这种维护方式效率低下，且容易出错。</li><li>在 GUI 自动化测试用例的数量比较多的情况下，你不希望只用一台测试执行机以串行的方式执行测试用例，而是希望可以用上所有可用的测试执行机，以并发的方式执行测试用例，以加快测试速度。为了达到这个目的，你还是需要人工管理这些测试用例和测试执行机的对应关系。</li></ol><p><strong>这四种情况的问题，可以归结为：测试执行机与测试用例的关系是不透明的，即每个测试用例都需要人为设置测试执行机。</strong></p><p>为了改善这种局面，Selenium Grid 就应运而生了。</p><ul><li>一方面，使用 Selenium Grid 可以让测试机器的选择变得“透明”。也就是说，我们只要在执行测试用例时指定需要的浏览器版本即可，而无需关心如何找到合适的测试执行机。因为，这寻找符合要求的测试执行机的工作，Selenium Grid 可以帮你完成。</li><li>另一方面，Selenium Grid 的架构特点，天生就能很好地支持测试用例的并发执行。</li></ul><p>接下来，我就和你详细聊聊到底什么是 Selenium Grid，Selenium Grid 的架构是什么样的。</p><p><img src="https://static001.geekbang.org/resource/image/30/bf/3077a24abcd93f063c7510fb81ccf9bf.png" alt="Selenium Grid的架构"></p><p>从本质上讲，Selenium Grid 是一种可以并发执行 GUI 测试用例的测试执行机的集群环境，采用的是 HUB 和 Node 模式。这个概念有些晦涩难懂，我来举个例子吧。</p><p>假如，现在有个律师事务所要接受外来业务，那么就会有一个老大专门负责对外接受任务。收到任务后，这个老大会根据任务的具体要求找到合适的手下，然后将该任务分发给手下去执行。</p><p>那么，这个老大是怎么知道哪个手下最适合处理这个任务呢？其实，这个老大手下的每个人都会事先报备自己具备的技能，这样老大在分发任务的时候，就可以做到“有的放矢”了。</p><p>现在，我们再回到 Selenium Grid。Selenium Grid 由两部分构成，一部分是 Selenium Hub，另一部分是 Selenium Node。</p><p>将这个律师事务所的例子，与 Selenium Grid 做个类比，它们的对应关系是：</p><ul><li>这个对外的老大对应的是 Selenium Hub；</li><li>具体执行任务的手下，对应的是 Selenium Node；</li><li>老大接到任务后分配给手下执行的过程，就是 Selenium Hub 将测试分配到 Selenium Node 执行的过程；</li><li>老大的手下向他报备自己技能的过程，就是 Selenium Node 向 Selenium Hub 注册的过程。</li></ul><p>也就是说，<strong>Selenium Hub 用来管理各个 Selenium Node 的注册信息和状态信息，并且接收远程客户端代码的测试调用请求，并把请求命令转发给符合要求的 Selenium Node 执行</strong>。</p><p>现在，我们已经搞明白了什么是 Selenium Grid，以及 Selenium Grid 的工作模式。Selenium Grid 的功能是不是很酷炫呢？那么，Selenium Grid 的搭建是不是很难？接下来，我们就看看如何搭建自己的 Selenium Grid 吧。</p><p>在这里，我会依次给你介绍传统的 Selenium Grid 和基于 Docker 的 Selenium Grid 的搭建方法。通过这部分内容我要达到的目的是，可以帮你搭建起属于自己的 Selenium Grid。</p><p><strong>传统 Selenium Grid 的搭建方法</strong></p><p>我将通过一个实例，和你分享如何搭建一个传统的 Selenium Grid。</p><p>现在，我们的需求是，搭建一个具有 1 个 Node 的 Selenium Grid。那么通常来讲我们需要 2 台机器，其中一台作为 Hub，另外一台作为 Node，并要求这两台机器已经具备了 Java 执行环境。</p><ol><li>通过官网下载 selenium-server-standalone-.jar 文件。这里需要注意的是，不管是 Hub 还是 Node，都使用同一个 JAR 包启动，只是启动参数不同而已。</li><li>将下载的 selenium-server-standalone-.jar 文件分别复制到两台机器上。</li><li>选定其中一台机器作为 Selenium Hub，并在这台机器的命令行中执行以下命令：</li></ol><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token function">java</span> <span class="token parameter variable">-jar</span> selenium-server-standalone-version.jar <span class="token parameter variable">-role</span> hub</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>java -jar selenium-server-standalone-version.jar -role hub 在这条命令中，“-role hub”的作用是将该机器启动为 Selenium Hub。启动完成后，这台机器默认对外提供服务的端口是 4444。</p><p>然后，你就可以在这台机器上通过 http://localhost:4444/grid/console 观察 Selenium Hub 的状态，也可以在其他机器上通过 http://Hub_IP:4444/grid/console 观察 Selenium Hub 的状态。其中，Hub_IP 是这台 Selenium Hub 机器的 IP 地址。由于此时还没有 Node 注册到该 Hub 上，所以你看不到任何的 Node 信息。</p><p>启动过程和状态信息，分别如图 2、3 所示。</p><p><img src="https://static001.geekbang.org/resource/image/a2/98/a275424067255c72da249734a203ba98.png" alt="Selenium Hub启动过程"></p><p><img src="https://static001.geekbang.org/resource/image/3d/15/3d73539d2b14aa45d4f2b19334eb9a15.png" alt="没有挂载任何Node的Selenium Hub"></p><ol start="4"><li>在另一台作为 Selenium Node 的机器上执行以下命令：</li></ol><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token function">java</span> <span class="token parameter variable">-jar</span> selenium-server-standalone-version.jar <span class="token parameter variable">-role</span> <span class="token function">node</span> <span class="token parameter variable">-hub</span> http:// Hub_IP:4444/grid/register</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这条命令中，“-role node”的作用是，将该机器启动为 Selenium Node，并且通过“-hub”指定了 Selenium Hub 的节点注册 URL。</p><p>执行成功后，你可以再次打开 http://Hub_IP:4444/grid/console 观察 Selenium Hub 的状态。此时，你可以看到已经有一个 Node 挂载到了 Hub 上。这个 Node，就是用来实际执行测试的机器了。并且，这个 Node 上已经缺省提供了 5 个 Firefox 浏览器的实例、5 个 Chrome 浏览器的实例和 1 个 IE 浏览器的实例，同时默认允许的并发测试用例数是 5 个。</p><p>如果你想自己配置这些内容，可以在启动 Node 的时候提供不同的启动参数。具体可以指定哪些参数，你可以参考<a href="https://github.com/SeleniumHQ/selenium/wiki/Grid2" target="_blank" rel="noopener noreferrer">Selenium Grid</a>的官方文档。</p><p>如图 4 所示为 Node 的启动过程，如图 5 所示为在 Hub 端注册 Node 的过程，如图 6 所示为挂载完 Node 后 Selenium Hub 的状态。</p><p><img src="https://static001.geekbang.org/resource/image/db/96/db5edbf3d119ac17710a9640d905c596.png" alt="Node的启动过程"></p><p><img src="https://static001.geekbang.org/resource/image/3e/4b/3e4133f06d2cc5d812cef1f8f375c74b.png" alt="Hub端Node注册的过程"></p><p><img src="https://static001.geekbang.org/resource/image/58/06/58bf48cb7af0db82546902a3a5c99406.png" alt="挂载完Node后的Selenium Hub状态"></p><ol start="5"><li>完成上述操作后，在测试用例中通过以下代码将测试指向 Selenium Hub，然后由 Selenium Hub 完成实际测试执行机的分配与调度工作。其中，最关键的部分是，创建 RemoteWebDriver 实例的第一个参数，这个参数不再是一个具体的测试执行机的 IP 地址或者名字了，而是 Selenium Hub 的地址。</li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token class-name">DesiredCapabilities</span> capability <span class="token operator">=</span> <span class="token class-name">DesiredCapabilities</span><span class="token punctuation">.</span><span class="token function">firefox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">WebDriver</span> driver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteWebDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">&quot;http://&lt;Hub_IP&gt;:4444/wd/hub&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> capability<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，我们就已经完成了 Selenium Grid 的搭建工作。正如上面的五个步骤所示，这个搭建过程非常简单。接下来，你就自己动手尝试一下吧。</p><p><strong>基于 Docker 的 Selenium Grid 的搭建方法</strong></p><p>目前，Docker 技术的广泛普及，再加上它的轻量级、灵活性等诸多优点，使得很多软件都出现了 Docker 版本。当然，Selenium Grid 也不例外。所以，我也会在这里和你简单介绍一下基于 Docker 的 Selenium Grid 搭建过程。</p><p>在这个搭建过程中，你将会发现基于 Docker 运行 Selenium Grid 的话，机器的利用率会得到大幅提高。因为，一台实体机或者虚拟机，往往可以运行非常多的 Docker 实例数量，而且 Docker 实例的启动速度也很快。因此，相对于虚拟机或者实体机方案而言，Docker 方案可以更高效地创建 Node。</p><p>接下来，我们就一起看看如何基于 Docker 来搭建 Selenium Grid 吧。</p><p>在基于 Docker 搭建 Selenium Grid 之前，你需要先安装 Docker 环境。具体安装方法，你可以参考<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener noreferrer">Docker 的官方文档</a>。</p><p>接下来，你就可以通过以下命令分别启动 Selenium Hub 和 Selenium Node 了。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token comment">#创建了Docker的网络grid</span></span>
<span class="line">$ <span class="token function">docker</span> network create grid</span>
<span class="line"></span>
<span class="line"><span class="token comment">#以Docker容器的方式启动Selenium Hub，并且对外暴露了4444端口</span></span>
<span class="line">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">4444</span>:4444 <span class="token parameter variable">--net</span> grid <span class="token parameter variable">--name</span> selenium-hub selenium/hub:3.14.0-europium</span>
<span class="line"></span>
<span class="line"><span class="token comment">#以Docker容器的方式启动并挂载了Chrome的Selenium Node</span></span>
<span class="line">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--net</span> grid <span class="token parameter variable">-e</span> <span class="token assign-left variable">HUB_HOST</span><span class="token operator">=</span>selenium-hub <span class="token parameter variable">-v</span> /dev/shm:/dev/shm selenium/node-chrome:3.14.0-europium</span>
<span class="line"></span>
<span class="line"><span class="token comment">#以Docker容器的方式启动并挂载了Firefox的Selenium Node</span></span>
<span class="line">$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--net</span> grid <span class="token parameter variable">-e</span> <span class="token assign-left variable">HUB_HOST</span><span class="token operator">=</span>selenium-hub <span class="token parameter variable">-v</span> /dev/shm:/dev/shm selenium/node-firefox:3.14.0-europium</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比基于实体机或者虚拟机搭建 Selenium Grid 的方法，基于 Docker 的方式灵活性更大、启动效率也更高、可维护性也更好。而且，在更高级的应用中，比如当我们需要根据测试用例的排队情况，动态增加 Selenium Grid 中的 Node 数量的时候，Docker 都将是最好的选择。关于这部分内容具体的细节，我会在后面两篇文章中详细展开。</p><p><strong>总结</strong></p><p>今天，我从测试基础架构的概念讲起，并和你分享了传统 Selenium Grid 和基于 Docker 的 Selenium Grid 的搭建方法。</p><p>首先，测试基础架构指的是，执行测试的过程中用到的所有基础硬件设施以及相关的软件设施，包括了执行测试的机器、测试用例代码仓库、统一的测试执行平台等。而，今天我针对测试执行的机器这个主题展开了分享。</p><p>在最早起的测试执行场景中，采用的方法是由人工维护一批数量不多（通常在 30 台以内）的执行测试的机器，然后按需使用，完成整个测试过程，这也是典型的“小作坊”模式。随着测试需求日益复杂，“小作坊”模式的缺点也暴露无疑，其中最主要的问题在于：测试执行机和测试用例的对应关系不“透明”，以及由此带来的测试用例并发执行难以实施的问题。</p><p>于是，为了解决这个问题，就出现了 Selenium Grid。简单地说，Selenium Grid 就是一种可以并发执行 GUI 测试用例的测试执行机的集群环境。由于它采用的是 Hub 和 Node 的架构模式，所以很容易就解决了“小作坊”模式的测试用例与测试执行机间的不“透明”关系，以及测试用例并发执行的问题。</p><p>而 Selenium Grid 的搭建也是非常简单。其中，传统 Selenium Grid 搭建时只要在理解了 Selenium Grid 架构之后，通过 Java 命令分别启动 Hub 和 Node 即可；而基于 Docker 的 Selenium Grid 在搭建时，就更简单了，直接通过 Docker 命令运行已经封装好的 Image 就可以了。</p><p>这么来看，Selenium Grid 功能强大，搭建方法更是简单，也因此已经广泛应用于测试执行环境的搭建中。</p><p><strong>思考题</strong></p><p>目前 Selenium Grid 已经有 Docker 的版本了，你有没有考虑过可以在云端，比如 PCF、GCP、AWS 上搭建 Selenium Grid 呢？在我看来，这将是未来的主流方案，你也是类似的看法吗？</p>`,68)]))}const t=n(l,[["render",r]]),u=JSON.parse('{"path":"/1.capacity/22.%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9552%E8%AE%B2/39.html","title":"39 讲：从小作坊到工厂：什么是 SeleniumGrid？如何搭建 SeleniumGrid？","lang":"zh-cn","frontmatter":{},"headers":[],"git":{"updatedTime":1745032055000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":6,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"a2b6e78156eb7f1fed6ecb0952cc98c6b90aa9d3","time":1745032055000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"change hierarchy"},{"hash":"cf1a535ce24165a7f8da8bf85c1c9f2de88d6068","time":1692634731000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: change the groups"},{"hash":"24795fa27668d9eb86a60f67b09182b15314e9bc","time":1682330132000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"chore: structure adjust big big"},{"hash":"4c687b02f79ccdfcaa65d9982bca03a44b676fad","time":1682215016000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"refactor: adjust folders"},{"hash":"c7687267bae8f86db250f135ac6d09ee4b7ad286","time":1651754553000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"fix: tag error"},{"hash":"8d0cb6f2505e606c88de1252efd2eb0c19ee91e3","time":1651754263000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: 20220505"}]},"filePathRelative":"1.capacity/22.软件测试52讲/39.md"}');export{t as comp,u as data};
