import{_ as n,c as a,b as e,o as l}from"./app-C01vnHKY.js";const i={};function t(p,s){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="sql-相关" tabindex="-1"><a class="header-anchor" href="#sql-相关"><span>SQL 相关</span></a></h1><h2 id="性能优化相关" tabindex="-1"><a class="header-anchor" href="#性能优化相关"><span>性能优化相关</span></a></h2><ul><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 Where 及 order by 涉及的列上建立索引。</p></li><li><p>应尽量避免在 Where 子句中对字段进行 NULL 值判断，创建表时 NULL 是默认值，但大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。</p></li><li><p>应尽量避免在 Where 子句中使用!=或&lt;&gt;操作符， MySQL 只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的 LIKE。</p></li><li><p>应尽量避免在 Where 子句中使用 or 来连接条件， 否则将导致引擎放弃使用索引而进行全表扫描， 可以 使用 UNION 合并查询：select id from t where num=10 union all select id from t where num=20。</p></li><li><p>in 和 not in 也要慎用，否则会导致全表扫描，对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3。</p></li><li><p>下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’ 或者 select id from t where name like ‘%abc’若要提高效率，可以考虑全文检索。而 select id from t where name like ‘abc%’ 才用到索引。</p></li><li><p>如果在 Where 子句中使用参数，也会导致全表扫描。</p></li><li><p>应尽量避免在 Where 子句中对字段进行表达式操作，应尽量避免在 Where 子句中对字段进行函数操作。</p></li><li><p>很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b).用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p></li><li><p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p></li><li><p>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p></li><li><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ， 因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p></li><li><p>使用表的别名(Alias)：当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个 Column 上.这样一来，就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误。</p></li><li><p>在 IN 后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p></li><li><p>尽量使用“&gt;=”，不要使用“&gt;”。</p></li><li><p>当有一批处理的插入或更新时，用批量插入或批量更新，不要一条条记录的去更新!</p></li><li><p>提高 GROUP BY 语句的效率，可以通过将不需要的记录在 GROUP BY 之前过滤掉。</p></li><li><p>别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快 1.5 倍。</p></li><li><p>索引创建规则：</p><ul><li>表的主键、外键必须有索引；</li><li>数据量超过 300 的表应该有索引；</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li><li>经常出现在 Where 子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；</li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段；</li><li>复合索引的几个字段是否经常同时以 AND 方式出现在 Where 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；</li><li>如果复合索引中包含的字段经常单独出现在 Where 子句中，则分解为多个单字段索引；</li><li>如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段；</li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li><li>频繁进行数据操作的表，不要建立太多的索引；</li><li>删除无用的索引，避免对执行计划造成负面影响；</li><li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。</li><li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li></ul></li><li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。</p></li><li><p>任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p></li><li><p>查询 SQL 尽量不要使用 select *，而是具体字段。</p></li><li><p>批量插入性能提升</p></li></ul><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line">NSERT <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;编程&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;妲己&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>复合索引最左特性，复合索引也称为联合索引，当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。联合索引不满足最左原则，索引一般会失效。</li><li>Text 类型优化，由于 Text 字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联。</li><li>Join 优化 Join 的实现是采用 Nested Loop Join 算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为过滤条件到下一个表中循环查询数据，然后合并结果。 如果有多个 Join，则将前面的结果集作为循环数据，再次到后一个表中查询数据。 驱动表和被驱动表尽可能增加查询条件，满足 ON 的条件而少用 Where，用小结果集驱动大结果集。 被驱动表的 Join 字段上加上索引，无法建立索引的时候，设置足够的 Join Buffer Size。 禁止 Join 连接三个以上的表，尝试增加冗余字段。</li></ul><h2 id="常用-sql-片段" tabindex="-1"><a class="header-anchor" href="#常用-sql-片段"><span>常用 SQL 片段</span></a></h2><h3 id="统计表数据条数" tabindex="-1"><a class="header-anchor" href="#统计表数据条数"><span>统计表数据条数</span></a></h3><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> a<span class="token punctuation">.</span>name 数据表<span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token keyword">rows</span> 数据总条数 <span class="token keyword">FROM</span> sysobjects <span class="token keyword">AS</span> a</span>
<span class="line"><span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> sysindexes <span class="token keyword">AS</span> b <span class="token keyword">ON</span> a<span class="token punctuation">.</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id</span>
<span class="line"><span class="token keyword">WHERE</span> <span class="token punctuation">(</span> a<span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token string">&#39;u&#39;</span> <span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">(</span> b<span class="token punctuation">.</span>indid <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> b<span class="token punctuation">.</span><span class="token keyword">rows</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="执行-sql-文件" tabindex="-1"><a class="header-anchor" href="#执行-sql-文件"><span>执行 SQL 文件</span></a></h3><div class="language-cmd line-numbers-mode" data-highlighter="prismjs" data-ext="cmd"><pre><code><span class="line">sqlcmd -S &lt;服务器名&gt; -d &lt;数据库名&gt; -U &lt;用户名&gt; -P &lt;密码&gt; -i &lt;SQL文件路径&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,10)]))}const c=n(i,[["render",t]]),r=JSON.parse('{"path":"/3.tech/12.tech-tricks/sql.html","title":"SQL 相关","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"性能优化相关","slug":"性能优化相关","link":"#性能优化相关","children":[]},{"level":2,"title":"常用 SQL 片段","slug":"常用-sql-片段","link":"#常用-sql-片段","children":[{"level":3,"title":"统计表数据条数","slug":"统计表数据条数","link":"#统计表数据条数","children":[]},{"level":3,"title":"执行 SQL 文件","slug":"执行-sql-文件","link":"#执行-sql-文件","children":[]}]}],"git":{"updatedTime":1745032055000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":3,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"a2b6e78156eb7f1fed6ecb0952cc98c6b90aa9d3","time":1745032055000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"change hierarchy"},{"hash":"a8add95c324a69fa93b30f7949270660ff8a1c66","time":1717043446000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: add some tricks"},{"hash":"9860dd23a4aeae3f0c9c1bffeff5be0c17eecee6","time":1716380632000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update 0522"}]},"filePathRelative":"3.tech/12.tech-tricks/sql.md"}');export{c as comp,r as data};
