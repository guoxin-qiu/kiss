import{_ as a,c as i,a as e,o as n}from"./app-Dmwo-0Oh.js";const h={};function s(r,l){return n(),i("div",null,l[0]||(l[0]=[e('<h1 id="用户故事与敏捷方法" tabindex="-1"><a class="header-anchor" href="#用户故事与敏捷方法"><span>用户故事与敏捷方法</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><h3 id="使用用户故事-不仅仅是为了快" tabindex="-1"><a class="header-anchor" href="#使用用户故事-不仅仅是为了快"><span>使用用户故事，不仅仅是为了快</span></a></h3><p>用户故事的确认环节，则是以反复的方式，与用户确认某个具体使用场景中的关键细节，从而不会导致遗漏。</p><p>从软件开发的角度入手，使用用户故事，从用户角度出发描述功能，这让我们可以站在最终用户的立场考虑问题，避免程序员自行其是。同时还能促使团队按功能特性实现需求，而不是按架构层次。</p><p>用户故事、规划会议等类似系列非技术实践，必须要结合 TDD、持续集成、重构等技术实现，否则要想产生高质量的代码就是空谈。</p><h2 id="第-1-章-概览" tabindex="-1"><a class="header-anchor" href="#第-1-章-概览"><span>第 1 章 概览</span></a></h2><p>软件需求是一个沟通问题。</p><h3 id="什么是用户故事" tabindex="-1"><a class="header-anchor" href="#什么是用户故事"><span>什么是用户故事</span></a></h3><p>用户故事描述了对用户、系统或软件购买者价值的功能。用户故事由以下三方面组成：</p><ul><li>一份书面的故事描述，用来做计划和作为提示</li><li>有关故事的对话，用于具体化故事细节</li><li>测试，用于表达和编档故事细节且可用于确定故事何时完成</li></ul><p>卡片（Card）、对话（Conversation）和确认（Confirmation） 客户来编写用户故事 客户团队和开发人员一起选择迭代长度。 一旦确定迭代长度，开发人员会估计每轮迭代中可以做多少事情。我们称之为速率（velocity）。</p><p>如果一个故事很大，我们有时候就称之为史诗故事（Epic）。史诗故事可以分成两个或更多的小故事。然而我们并不需要不断地分解故事，直到有一个故事能够覆盖每一个细节。用户故事不需要像经典的需求文档样式那样扩充细节。直到这些细节变得重要时才讨论。故事并不具有契约性质。达成的协议将由测试来记录，这些测试将演示故事是否被正确开发。</p><p>用户的期望最好以验收测试的形式被记录下来。测试描述可以简短、不完整，可以在任何时候加入或者删除。写这些测试描述的目的是传递故事的额外信息，以便于开发人员知道故事于什么时候结束。</p><p>对于故事驱动的项目而言，最引人瞩目的是客户和用户在项目整个过程中全程参与。我们不希望（或者不允许）他们在项目进行时离开。</p><p><em>客户为什么要编写故事？首先故事必须用商业预研来写而不是技术术语，客户团队可以排列故事的优先级，放入迭代和发布；其次作为主要的产品构想者，客户团队所处的位置最适合描述产品行为。</em></p><h3 id="规划发布和迭代" tabindex="-1"><a class="header-anchor" href="#规划发布和迭代"><span>规划发布和迭代</span></a></h3><p>在进行发布规划时，客户团队首先从排列故事优先级开始。考虑以下几点：</p><ul><li>大部分用户和客户对特定特性的渴望程度</li><li>小部分重要用户和客户对特定特性的渴望程度</li><li>故事之间的关系</li></ul><p>客户团队应该倾听开发人员基于技术风险方面的考虑，但是随后排列故事优先级时，应该坚持客户组织利益最大化的原则。</p><h3 id="验收测试" tabindex="-1"><a class="header-anchor" href="#验收测试"><span>验收测试</span></a></h3><p>验收测试用来验证实现的用户故事是否符合客户团队的期望。 测试应该尽早的在迭代中编写，客户团队的假设和预期会更早与开发人员沟通。</p><h3 id="为什么要编写故事卡而不继续需求文档或者用例" tabindex="-1"><a class="header-anchor" href="#为什么要编写故事卡而不继续需求文档或者用例"><span>为什么要编写故事卡而不继续需求文档或者用例</span></a></h3><ul><li>用户故事强调对话交流而不是书面沟通</li><li>用户故事可以同时被你和开发人员理解</li><li>用户故事的大小适合于做计划</li><li>用户故事适用于迭代开发</li><li>用户故事鼓励推迟考虑细节，知道你非常清楚地了解自己的真正需求</li></ul><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h3><ul><li>故事卡包含对用户或者客户有价值的功能的简短描述。</li><li>故事卡时故事的可见部分，但客户团队和开发人员关于故事的对话更重要。</li><li>客户团队包括那些确保软件符合潜在用户需求的人，可以包括测试人员、产品经理、实际用户和交互设计师。</li><li>故事卡由客户团队编写，因为他们最了解如何表达需要实现的需求，也因为他们会在后期与开发人员共同确定故事细节并安排故事的优先级顺序。</li><li>按照故事对客户的价值来安排故事的优先级顺序。</li><li>将各个故事放入迭代，进行发布于迭代规划。</li><li>速率时开发人员可以在一轮迭代中完成的工作量。</li><li>放入一轮迭代的故事估计综合不能超过事先开发人员预计的速率。</li><li>如果故事太大以至于无法在一轮迭代中完成，可以考虑把它分为两个或更多的小故事。</li><li>验收测试用于验证实现的故事是否开发成符合客户团队的设想。</li><li>用户故事是很有意义的，因为它们强调口头交流，你和开发人员都可以理解，可以用户进行迭代计划，在迭代开发过程中能很好地工作，而且因为它们鼓励推迟细节。</li></ul><h2 id="第-2-章-编写故事" tabindex="-1"><a class="header-anchor" href="#第-2-章-编写故事"><span>第 2 章 编写故事</span></a></h2><h3 id="用户故事六个特征" tabindex="-1"><a class="header-anchor" href="#用户故事六个特征"><span>用户故事六个特征</span></a></h3><ul><li><p>独立的（Independent） 避免互相依赖 如果出现相互依赖的故事可以：将相互依赖的故事合并成一个大的、独立的故事；用一个不同的方式去分割故事；给两个不同的估算</p></li><li><p>可讨论的（Negotiable） 如果故事过于详细，会导致一种错觉：故事卡反映了所有细节，没有必要跟客户进行进一步的讨论</p></li><li><p>对用户或客户有价值的（Valuable to Purchasers or Users） 故事卡只是提醒客户需要之后进行需求讨论，而不是一个正式的承诺或某个功能的具体描述。开发人员不要使客户觉得他们写下来的任何东西都可能成为未来对他们不利的证据 隐含测试用例的细节要和故事本身分开 避免只对开发人员有价值（技术细节和实现细节）的故事 避免在故事中出现用户界面和技术方面的定义</p></li><li><p>可估计的（Estimable） 导致故事不可估计的原因： 开发人员缺少领域知识，应该和写故事的客户一起讨论； 开发人员缺少技术知识，可实施探针试验（spike），不需要做十分深入的研究，只要能大体了解足够信息来估计这个任务即可。探针试验本身总是会限定一个最大时间量（时间盒，timebox），如此一个不可估计的故事就变成了两个故事，一个快速的探针故事（用来获得足够的信息）和一个故事（真正实现功能）。考虑将探针试验放在不同的迭代中； 故事太大了，分解成更多个更小的故事；</p></li><li><p>小的（Small） Goldilocks：少儿英语 Goldilocks and The Three Bears 中的女主人翁，这个单词后来用于表示“刚刚好” 分割史诗故事：复合故事（compound story）和复杂故事（complex story）</p></li><li><p>可测试的（Testable） 尽可能的自动化测试。有些需要人为因素专家（human factor expert）设计一个测试来观察一批随机的典型新用户。</p><h3 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1"><span>小结</span></a></h3><ul><li>理想情况下，故事之间是独立的。有时候很难做到这一点，但我们要尽量实现这一目标。故事之间的交付顺序应该是无关的，可以任意拿一个故事来实现。</li><li>故事细节由用户和开发人员讨论得出。</li><li>故事应该很清晰地体现对用户或客户的价值。最好的做法是让客户编写故事。</li><li>故事可以注释一些细节，但是过多的细节会使故事难以理解，也可能给人一种开发人员和客户无需交谈的错觉。</li><li>给故事加上注释的最好方法是给它编写测试用例。</li><li>如果故事太大，复合故事和复杂故事可以分成几个小的故事。</li><li>如果故事太小，几个小故事可以合并成一个较大的故事。</li><li>故事应该是可以测试的。</li></ul><h3 id="开发人员职责" tabindex="-1"><a class="header-anchor" href="#开发人员职责"><span>开发人员职责</span></a></h3><ul><li>负责帮助客户编写故事，这些故事要能提醒你们同客户交谈，而不是记录详细的需求定义，故事应该对用户或者客户有价值，它们是独立的、可测的、大小合适的。</li><li>如果被问及实现故事所用的技术或者基础架构信息，应该使用对用户或客户有价值的术语来描述。</li></ul><h3 id="客户团队职责" tabindex="-1"><a class="header-anchor" href="#客户团队职责"><span>客户团队职责</span></a></h3><ul><li>负责编写故事，这些故事要能提醒你们同开发人员交谈，而不是记录详细的需求定义，它们对用户或你们自己是有价值的，它们是独立的、可测试的、大小合适的。</li></ul></li></ul><h2 id="第-3-章-用户角色建模" tabindex="-1"><a class="header-anchor" href="#第-3-章-用户角色建模"><span>第 3 章 用户角色建模</span></a></h2><p>在很多项目中，需求分析人员只是从一个角度写用户故事，往往容易忽略一些需求（故事），因为有些故事针对的并不是系统的一般用户。 以用户为中心的设计（usage-centered design），交互设计（interaction design）</p><h3 id="用户角色" tabindex="-1"><a class="header-anchor" href="#用户角色"><span>用户角色</span></a></h3><p>用户角色、角色建模、角色映射、虚构人物、极端人物。</p><h3 id="角色建模的步骤" tabindex="-1"><a class="header-anchor" href="#角色建模的步骤"><span>角色建模的步骤</span></a></h3><ul><li><p>通过头脑风暴，列出初始的用户角色集合 客户和开发人员（多多益善）一起</p></li><li><p>整合最初的角色集合 尽量坚持一个原则：用户角色的定义是人，而不是其他外部系统</p></li><li><p>整合角色</p></li><li><p>提炼角色</p><ul><li>用户使用软件的频率</li><li>用户在相关领域的知识水平</li><li>用户使用计算机和软件的总体水平</li><li>用户对当前正在开发的软件的熟悉程度</li><li>用户使用该软件的总体目标。有些用户注重使用的便捷性，有些关注丰富的用户体验</li></ul><h3 id="小结-2" tabindex="-1"><a class="header-anchor" href="#小结-2"><span>小结</span></a></h3><ul><li>大部分项目小组只考虑单一的用户类型。这回导致软件忽略原本需要的一些用户类型。</li><li>为了避免从单一用户的角度编写所有故事，要识别于软件交互的不同用户角色。</li><li>通过对每个用户角色定义相关特征，可以更清楚地看到不同角色间的不同点。</li><li>对于有些用户角色而言，用代表人物来描述会很有帮助。虚构人物是假象出来的用户角色代表。他们有名字，有照片，还有足够的相关细节，因为对项目成员来说，很真实。</li><li>对于有些应用程序，极端人物可能有助于搜集原本被遗漏的故事。</li></ul><h3 id="开发人员职责-1" tabindex="-1"><a class="header-anchor" href="#开发人员职责-1"><span>开发人员职责</span></a></h3><ul><li>负责参与确认用户角色和虚构人物的过程。</li><li>负责理解每个用户角色和虚构人物，以及它们之间的异同。</li><li>开发软件时，负责考虑不同的用户角色对于软件如何运行的不同偏好。</li><li>负责确保在识别和描述用户角色时，它们只是这个过程中的工具，不应超越作为工具之外的任何用途。</li></ul><h3 id="客户职责" tabindex="-1"><a class="header-anchor" href="#客户职责"><span>客户职责</span></a></h3><ul><li>负责寻找用户（多多益善），并识别恰当的用户角色。</li><li>负责参与识别用户角色和虚构人物的过程。</li><li>负责确保软件没有关注不恰当的用户。</li><li>在编写故事时，负责确保每个故事都能和至少一个用户角色或虚构人物联系起来。</li><li>开发软件时，负责考虑不同的用户角色对于软件如何运行的不同偏好。</li><li>负责确保在识别和描述用户角色时，它们只是这个过程中的工具，不应超于作为工具之外的任何用途。</li></ul></li></ul><h2 id="第-4-章-搜集故事" tabindex="-1"><a class="header-anchor" href="#第-4-章-搜集故事"><span>第 4 章 搜集故事</span></a></h2><h3 id="引出和捕捉是不合用的" tabindex="-1"><a class="header-anchor" href="#引出和捕捉是不合用的"><span>引出和捕捉是不合用的</span></a></h3><p>一些需求相关的书中用到了像“引出”和“捕捉”这样的词来描述识别与确认需求的实践。这样的术语给我们一种错觉：“需求本来已经存在了，我们只要让客户给我们解释需求，然后把它们锁入一个笼子里就可以了”。很多需求并不容易想到，同样，用户并不知道所有的需求，所以不能单纯依靠引出（elicitation）。</p><ul><li>拖网（trawling）</li></ul><h3 id="够用就行-不是吗" tabindex="-1"><a class="header-anchor" href="#够用就行-不是吗"><span>够用就行，不是吗</span></a></h3><p>传统规范过程的特征是它过分强调在项目早期正确地获取并写出所有的需求。敏捷项目则承认没有一种理想的方法可以在一个单一阶段获取到所有的用户故事。 敏捷过程也承认用户故事有一个时间维度：随着时间的推移以及先前迭代中加入产品的故事，一个故事的相关性（relevance）会有所变化。</p><h3 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h3><p>故事会随着项目的进展而演进。</p><ul><li><p>用户访谈 选择正确的受访者 只询问用户“你们需要什么”是不够的，用户不善于理解和表达真实需求 仅因为有些问题由用户提出就认为只有用户才有资格提出解决方案是错误的 开放式问题和背景无关问题，不要暗含答案和喜好</p></li><li><p>问卷调查</p></li><li><p>观察 观察用户实际使用软件的情况</p></li><li><p>故事编写工作坊 开发人员、用户、产品客户和其他对编写故事有帮助的人共同参加的会议。 良好的故事编写工坊结合了头脑风暴的最佳要素和简单原型法。 原型不关注细节，画好几天内丢掉，防止不必要的困惑 在画原型的过程中，问一些有助于找到遗漏故事的问题，问问题的时候考虑下当时用户的角色</p><ul><li>用户接下来最有可能做什么</li><li>用户会在这里犯什么错误</li><li>在这里，用户会有什么困惑</li><li>用户需要什么额外的信息 故事编写工作坊期间，重点是数量而不是质量</li></ul><h3 id="小结-3" tabindex="-1"><a class="header-anchor" href="#小结-3"><span>小结</span></a></h3><ul><li>能够引出及捕捉需求这一想法是错误的。它有两个有问题的假设：用户知道所有的需求；需求一旦被捕捉，就锁定，不再改变。</li><li>拖网捕鱼的比喻是非常有用的：它说明了需求有不同的大小，需求会随着时间的推移变化，需要一些技巧来发现需求。</li><li>即使敏捷流程支持需求的后期涌现，依然需要对预期的发布进行展望并开始写下容易发现的的故事。</li><li>我们可以通过用户访谈、观察用户、问卷调查和举办故事编写工作坊来发现用户故事。</li><li>使用多种方法比过度使用一种方法更能获得好的效果。</li><li>通过开发式、与背景无关的题问更容易获得有用的答案，例如，“告诉我你想怎么搜索工作？”就胜于“你要通过职位名称来搜索工作吗？”</li></ul><h3 id="开发人员职责-2" tabindex="-1"><a class="header-anchor" href="#开发人员职责-2"><span>开发人员职责</span></a></h3><ul><li>负责理解并使用多种技巧来捕捞用户故事。</li><li>负责知道怎么使用开放式和背景无关的提问。</li></ul><h3 id="客户职责-1" tabindex="-1"><a class="header-anchor" href="#客户职责-1"><span>客户职责</span></a></h3><ul><li>负责理解并使用多种技巧来捕捞用户故事。</li><li>负责尽早写更多的用户故事。</li><li>作为软件用户的主要代表，负责和他们多沟通。</li><li>了解怎么使用开放式和背景无关的提问。</li><li>如果需要关于编写故事的帮助，负责安排并举办一次或多次故事编写工作坊。</li><li>负责确保在捕捞故事过程中考虑所有用户角色。</li></ul></li></ul><h2 id="第-5-章-与用户代理合作" tabindex="-1"><a class="header-anchor" href="#第-5-章-与用户代理合作"><span>第 5 章 与用户代理合作</span></a></h2><p>不同的用户代表了产品的不同角度，当无法接触到他们时，就需要求助于用户代理（user proxy），他们自己可能不是用户，但他们在项目里代表着用户。</p><h3 id="用户的经理" tabindex="-1"><a class="header-anchor" href="#用户的经理"><span>用户的经理</span></a></h3><p>用户的经理有时候是错误信息的来源。只要有可能，就要通过与实际用户交流来求证这些信息。</p><h3 id="开发经理" tabindex="-1"><a class="header-anchor" href="#开发经理"><span>开发经理</span></a></h3><p>让开发经理担任用户代理是最坏的选择之一。他们最想获取的是荣耀，他们的目的很可能是相互冲突的。例如：开发经理排列的故事优先级会不同于实际用户排列的，因为这样做可以让他提早给别人介绍令人兴奋的新技术。此外，开发经理的目标可能与企业目标不一致；或许他的年终奖跟项目的结束日期有关，这可能导致他想提前完成项目。</p><h3 id="销售人员" tabindex="-1"><a class="header-anchor" href="#销售人员"><span>销售人员</span></a></h3><p>对于销售人员来说，最重要的故事是那些如果没有实现就会导致她“丢单”的故事。 然而，销售人员是用户非常好的中转站，应该充分利用。</p><h3 id="领域专家" tabindex="-1"><a class="header-anchor" href="#领域专家"><span>领域专家</span></a></h3><p>潜在问题是，最终开发出的软件可能仅仅针对那些与领域专家有类似水平的用户。领域专家会倾向于将项目指向适合他们自己的解决方案上进行，但这往往过于复杂，对目标用户群体而言明显是错误的。</p><h3 id="市场营销团队" tabindex="-1"><a class="header-anchor" href="#市场营销团队"><span>市场营销团队</span></a></h3><p>了解市场的是营销团队，而不是用户。这会导致营销团队或者有营销背景的人更关注产品特性的数量，而轻视特性的质量。</p><h3 id="以前的用户" tabindex="-1"><a class="header-anchor" href="#以前的用户"><span>以前的用户</span></a></h3><p>应谨慎考虑她的目标和动机是否与实际用户的完全一致。</p><h3 id="客户" tabindex="-1"><a class="header-anchor" href="#客户"><span>客户</span></a></h3><p>客户是那些做出购买决定的人，他们不一定是软件的用户。</p><h3 id="培训师和技术支持" tabindex="-1"><a class="header-anchor" href="#培训师和技术支持"><span>培训师和技术支持</span></a></h3><h3 id="业务分析师或系统分析师" tabindex="-1"><a class="header-anchor" href="#业务分析师或系统分析师"><span>业务分析师或系统分析师</span></a></h3><p>很好的用户代理，既懂技术又熟悉软件相关的领域知识。能平衡好这些背景且努力跟实际用户沟通的分析实，通常会时非常出色的用户代理。 有些分析师暴露出来的问题是，他们遇到问题喜欢空想，而不是去做调查。 分析师可能在项目前期花费太多时间。</p><h3 id="与用户代理合作时-做些什么" tabindex="-1"><a class="header-anchor" href="#与用户代理合作时-做些什么"><span>与用户代理合作时，做些什么？</span></a></h3><p>能接触到用户但访问受限时：请求准许启动一个用户顾问团队（User Task Force），由实际用户组成，能够提出意见和建议，而用户代理依然是项目最终的决策者。 实在不能接触到用户时：一种是使用多个用户代理；一种是尽早发布产品。</p><h3 id="设立客户团队" tabindex="-1"><a class="header-anchor" href="#设立客户团队"><span>设立客户团队</span></a></h3><ul><li>邀请真实用户加入。</li><li>确定一位“项目负责人”（Project Champion）或“一把手”（First Among Equals），只能有一个客户声音。</li><li>确定项目成功必须的关键因素。</li></ul><h3 id="小结-4" tabindex="-1"><a class="header-anchor" href="#小结-4"><span>小结</span></a></h3><ul><li>除非用户的经理也是用户，否则她就不是合适的用户代理。</li><li>开发经理会试图担任用户代理，因为他们已经参与到项目每天的细节中。然而，开发经理大多不是正在开发的软件的用户，所以他们不是理想的用户代理。</li><li>在产品公司里，客户经常来自市场团队。来自市场团队的人经常是不错的用户代理，但他们通常关注于软件的功能数目，而不是其质量，这点必须要克服。</li><li>与很多不同的客户（而这些客户同时也是用户）联系的销售人员可以是很好的开发项目客户。销售人员必须避免把重点放在那些可以重新赢得已失去订单的故事上。在所有情况下，销售人员是与用户沟通的有效渠道。</li><li>领域专家可以成为优秀的用户代理，但必须避免一点：在为产品编写故事时，将产品开发成只适合那些与他们有相同水平的人使用。</li><li>客户，那些做出购买决定的人，如果他们能与用户密切地交流，那么他们能成为非常好的用户代理。显然，如果客户自己也是用户，那就是完美的组合。</li><li>为了成为好的用户代理，培训师和技术支持人员必须避免仅仅关注产品中那些他们每天关心的方面。</li><li>与用户代理一起工作的方法，包括用户顾问团队的使用，使用多个用户代理，分析竞争产品，尽早发布软件来获取用户反馈。</li></ul><h3 id="开发人员职责-3" tabindex="-1"><a class="header-anchor" href="#开发人员职责-3"><span>开发人员职责</span></a></h3><ul><li>负责帮助组织机构为项目无色合适的客户。</li><li>负责了解不同类型的用户代理怎么考虑你们正在开发的系统，他们的背景如何影响交互。</li></ul><h3 id="客户团队职责-1" tabindex="-1"><a class="header-anchor" href="#客户团队职责-1"><span>客户团队职责</span></a></h3><ul><li>如果你不是软件的用户，则要负责了解自己属于哪类用户代理。</li><li>负责理解自己会将哪些偏见带入到项目中，如何克服这个问题，无论是依靠别人还是其他方法。</li></ul><h2 id="第-6-章-用户故事验收测试" tabindex="-1"><a class="header-anchor" href="#第-6-章-用户故事验收测试"><span>第 6 章 用户故事验收测试</span></a></h2><p>可以用测试来充实很多用户故事的细节。 测试是一个两步流程：第一，将测试要点记录在故事卡的背面，任何时候发现新的测试，都可以记录到故事卡的背面；第二，将测试要点变成全面的测试，这些测试可以用来演示故事已正确、完整地实现。</p><h3 id="在写代码之前写测试" tabindex="-1"><a class="header-anchor" href="#在写代码之前写测试"><span>在写代码之前写测试</span></a></h3><ul><li>开发人员和客户讨论故事且需要记录明确的细节时</li><li>在迭代开始时，在写代码前作为一项专门的任务</li><li>在开发中或之后的任何时候发现新的测试时</li></ul><p>理想状态下，在客户和开发人员讨论故事的时候，把细节都写成测试。</p><ul><li>关于这个故事，程序员还需要知道什么？</li><li>对怎么实现这个故事，我的想法是什么？</li><li>有没有一些特殊的情况会使这个故事有不一样的行为？</li><li>这个故事在什么情况会出错？</li></ul><h3 id="客户定义测试" tabindex="-1"><a class="header-anchor" href="#客户定义测试"><span>客户定义测试</span></a></h3><p>既然软件是用来实现用户的愿景，验收测试当然就应当由客户来定义。</p><h3 id="测试是过程的一部分" tabindex="-1"><a class="header-anchor" href="#测试是过程的一部分"><span>测试是过程的一部分</span></a></h3><p>测试人员总是按照程序员的描述去测试，如果没有客户或用户的参与，我们不会真正从他们的角度来测试软件。 测试是开发过程中的一部分，而不是在编码完成后要做的事情，这点对使用用户故事非常重要。一般情况下，产品经理和测试人员共同负责列出详细的测试。产品经理带来驱动项目的公司目标的知识，测试人员则带来怀疑的心态。</p><h3 id="多少测试才算多" tabindex="-1"><a class="header-anchor" href="#多少测试才算多"><span>多少测试才算多？</span></a></h3><p>只要这些测试还在继续为故事增加价值和使它更加清晰，客户就应该继续写测试。客户不负责定义所有可能的测试。客户应该更专注于那些能向开发团队说明故事意图的测试。</p><h3 id="测试类型" tabindex="-1"><a class="header-anchor" href="#测试类型"><span>测试类型</span></a></h3><p>测试的是缺陷，而不是覆盖率</p><ul><li>用户交互测试，确保所有用户交互组件如期工作。</li><li>可用性测试，确保程序好用。</li><li>性能测试，测量应用程序在各种负荷下的工作状况。</li><li>压力测试，使应用程序在用户和事务的极限值情况或其他任何让应用程序处在压力下的情况运行。</li></ul><h3 id="小结-5" tabindex="-1"><a class="header-anchor" href="#小结-5"><span>小结</span></a></h3><ul><li>验收测试可以用来记录客户和开发人员讨论的很多细节。</li><li>验收测试记录了有关故事的一些假设，这些假设可能还没有和开发人员讨论过。</li><li>验收测试提供了检查故事是否被完整实现的基本标准。</li><li>验收测试应由客户来写而不是开发人员。</li><li>验收测试应在程序员写代码之前就写好。</li><li>如果新的测试对阐明故事的细节或意图没有任何帮助，就不用再写。</li></ul><h3 id="开发人员职责-4" tabindex="-1"><a class="header-anchor" href="#开发人员职责-4"><span>开发人员职责</span></a></h3><ul><li>若团队觉得有需要，则负责实现自动化验收测试。</li><li>开始发现一个新的故事时，负责考虑更多的验收测试。</li><li>负责为代码做单元测试，使验收测试就不必估计故事的每个细节。</li></ul><h3 id="客户职责-2" tabindex="-1"><a class="header-anchor" href="#客户职责-2"><span>客户职责</span></a></h3><ul><li>负责编写验收测试。</li><li>负责执行验收测试。</li></ul><h2 id="第-7-章-优秀用户故事准则" tabindex="-1"><a class="header-anchor" href="#第-7-章-优秀用户故事准则"><span>第 7 章 优秀用户故事准则</span></a></h2><h3 id="从目标故事开始" tabindex="-1"><a class="header-anchor" href="#从目标故事开始"><span>从目标故事开始</span></a></h3><h3 id="切蛋糕" tabindex="-1"><a class="header-anchor" href="#切蛋糕"><span>切蛋糕</span></a></h3><h3 id="编写封闭的故事" tabindex="-1"><a class="header-anchor" href="#编写封闭的故事"><span>编写封闭的故事</span></a></h3><p>封闭故事是指随着一个有意义的目标的实现而结束的故事，能让用户使用后觉得他完成了某个任务。</p><h3 id="卡片约束" tabindex="-1"><a class="header-anchor" href="#卡片约束"><span>卡片约束</span></a></h3><p>对于任何必须要遵守而不需要直接实现的故事，在其故事卡上标注“约束”（constraint）。</p><h3 id="根据实现时间来确定故事规模" tabindex="-1"><a class="header-anchor" href="#根据实现时间来确定故事规模"><span>根据实现时间来确定故事规模</span></a></h3><h3 id="不要过早涉及用户界面" tabindex="-1"><a class="header-anchor" href="#不要过早涉及用户界面"><span>不要过早涉及用户界面</span></a></h3><h3 id="有些需求并不是故事" tabindex="-1"><a class="header-anchor" href="#有些需求并不是故事"><span>有些需求并不是故事</span></a></h3><p>如果需要，可以放心使用用户故事以外的其他形式来表达某些需求。</p><h3 id="在故事里包括用户角色" tabindex="-1"><a class="header-anchor" href="#在故事里包括用户角色"><span>在故事里包括用户角色</span></a></h3><h3 id="只为一个用户编写" tabindex="-1"><a class="header-anchor" href="#只为一个用户编写"><span>只为一个用户编写</span></a></h3><h3 id="以主语动态编写" tabindex="-1"><a class="header-anchor" href="#以主语动态编写"><span>以主语动态编写</span></a></h3><p>例如，不要写成“简历可以被求职者发布”，而要写成“求职者可以发布简历”</p><h3 id="由客户编写" tabindex="-1"><a class="header-anchor" href="#由客户编写"><span>由客户编写</span></a></h3><h3 id="向故事卡编号说-不" tabindex="-1"><a class="header-anchor" href="#向故事卡编号说-不"><span>向故事卡编号说“不”</span></a></h3><h3 id="不要忘记意图" tabindex="-1"><a class="header-anchor" href="#不要忘记意图"><span>不要忘记意图</span></a></h3><p>不要忘记，故事卡的主要目的是用来提醒开发人员和客户团队对功能进行讨论的。既然仅仅是一个提醒，就要保持它的简洁性。</p><h3 id="小结-6" tabindex="-1"><a class="header-anchor" href="#小结-6"><span>小结</span></a></h3><ul><li>为了确定故事，从每个用户角色使用系统的目标开始考虑。</li><li>分割故事时，试着将它分割成贯穿应用程序所有层面的故事。</li><li>试着让故事的大小能够在使用后让用户感到可以去喝杯咖啡休息一下。</li><li>如果有项目领域和环境的需要，可以用其他需求搜集或文档技术来补充故事。</li><li>创建约束卡，将它们贴在公共的墙上，或者编写测试来确保系统没有违反约束。</li><li>为团队即将实现的功能编写小的故事，针对未来实现的功能编写宽泛的、高层次的故事。</li><li>不要让故事过早涉及用户界面。</li><li>实际编写故事时，要包括用户角色。</li><li>用主动语态编写故事。</li><li>为单个用户编写故事。</li><li>让客户，而不是开发人员，编写故事。</li><li>用户故事要简短，别忘了，它们的目的是提醒开发人员和客户进行对话。</li><li>不要给故事卡编号。</li></ul><h2 id="第-8-章-估算用户故事" tabindex="-1"><a class="header-anchor" href="#第-8-章-估算用户故事"><span>第 8 章 估算用户故事</span></a></h2><h3 id="故事点-story-point" tabindex="-1"><a class="header-anchor" href="#故事点-story-point"><span>故事点（Story Point）</span></a></h3><h3 id="以团队估算" tabindex="-1"><a class="header-anchor" href="#以团队估算"><span>以团队估算</span></a></h3><p>故事估算应该由整个团队集体完成，两个原因：第一，还不确定团队中谁负责完成这个故事，所以应该把故事分配给整个团队而不是某个人。第二，团队决定的估算可能比个人估算更有用。</p><h3 id="估算" tabindex="-1"><a class="header-anchor" href="#估算"><span>估算</span></a></h3><p><em>所有事情都要花 4 小时</em> 估算一个故事，应考虑完成这个故事需做的所有事。要全盘考虑测试代码，和客户讨论，可能帮助客户计划或自动化验收测试等诸多因素。</p><h3 id="三角测量" tabindex="-1"><a class="header-anchor" href="#三角测量"><span>三角测量</span></a></h3><p>在估算一个故事时，根据这个故事与其他一个或多个故事的关系来估算。 三角测量是帮助团队验证他们没有逐渐改变一个故事点含义的有效方法。</p><h3 id="使用故事点" tabindex="-1"><a class="header-anchor" href="#使用故事点"><span>使用故事点</span></a></h3><p>估算的点数可以作为下轮迭代将完成的故事点数的预报。 获取一个平均的“速率”，要看生产力有没有受到影响（比如加班、加人等） 必须采用前后一致的方式进行估算。尽量减少从一轮迭代到下一个的速率的起伏。 第一轮迭代的故事必须是独立的。</p><p><em>中央极限定理（Central Limit Theorem），任意分部的独立样本数量之和是符合正态分布的。</em></p><h3 id="小结-7" tabindex="-1"><a class="header-anchor" href="#小结-7"><span>小结</span></a></h3><ul><li>用故事点估算故事，故事点是故事复杂度、工作量或工期的相对估算。</li><li>应由团队估算故事，估算属于团队而不是个人。</li><li>通过和其他估算进行比较来进行三角测量。</li><li>团队是否使用结对变成对故事点估算没有影响。结对变成影响的是团队的速率，不是他们的估算。</li></ul><h3 id="开发人员职责-5" tabindex="-1"><a class="header-anchor" href="#开发人员职责-5"><span>开发人员职责</span></a></h3><ul><li>负责用一个方式定义故事点，并且对团队可用和相关的。努力保证这个定义的一致性。</li><li>负责给出诚实的估算。不屈服于诱惑或压力而给出低的估算。</li><li>负责以团队估算。</li><li>负责估算应与其他估算一致。即所有 2 点的故事都应该差不多。</li></ul><h3 id="客户职责-3" tabindex="-1"><a class="header-anchor" href="#客户职责-3"><span>客户职责</span></a></h3><ul><li>负责参加估算会议，但是你的任务是回答问题并澄清故事细节。你不必参与故事估算。</li></ul><h2 id="第-9-章-发布计划" tabindex="-1"><a class="header-anchor" href="#第-9-章-发布计划"><span>第 9 章 发布计划</span></a></h2><h3 id="我们想在什么时候发布" tabindex="-1"><a class="header-anchor" href="#我们想在什么时候发布"><span>我们想在什么时候发布</span></a></h3><h3 id="希望在发布中包含哪些功能" tabindex="-1"><a class="header-anchor" href="#希望在发布中包含哪些功能"><span>希望在发布中包含哪些功能？</span></a></h3><p>MoSCoW：Must have, Should have, Could have, Won&#39;t have this time.</p><h3 id="排列故事的优先级" tabindex="-1"><a class="header-anchor" href="#排列故事的优先级"><span>排列故事的优先级</span></a></h3><p>通过多个维度来为故事排优先级。可以利用的技术要素如下：</p><ul><li>故事不能如期完成的风险</li><li>推迟实现一个故事时对其他故事的影响</li></ul><p>客户和用户对故事进行优先级排序时，要素如下：</p><ul><li>故事对于广泛用户或客户的重要性</li><li>故事对于少部分重要用户或客户的重要性</li><li>故事与其他故事的内聚性</li></ul><h3 id="混合优先级" tabindex="-1"><a class="header-anchor" href="#混合优先级"><span>混合优先级</span></a></h3><h3 id="高风险故事" tabindex="-1"><a class="header-anchor" href="#高风险故事"><span>高风险故事</span></a></h3><h3 id="根据架构需要安排优先级" tabindex="-1"><a class="header-anchor" href="#根据架构需要安排优先级"><span>根据架构需要安排优先级</span></a></h3><h3 id="选择迭代长度" tabindex="-1"><a class="header-anchor" href="#选择迭代长度"><span>选择迭代长度</span></a></h3><h3 id="从故事点到预计工期" tabindex="-1"><a class="header-anchor" href="#从故事点到预计工期"><span>从故事点到预计工期</span></a></h3><h3 id="初始速率" tabindex="-1"><a class="header-anchor" href="#初始速率"><span>初始速率</span></a></h3><ul><li>使用历史值</li><li>执行一轮初始迭代，使用那轮迭代的速率</li><li>猜测</li></ul><h3 id="创建发布计划" tabindex="-1"><a class="header-anchor" href="#创建发布计划"><span>创建发布计划</span></a></h3><p>利用发布计划可以设立初始期望，但之后如果获得新的信息，应该不断重更新调整期望。监控每轮迭代的速率，只要了解到由其他因素影响估算，就应该重新估算故事。</p><h3 id="小结-8" tabindex="-1"><a class="header-anchor" href="#小结-8"><span>小结</span></a></h3><ul><li>在计划发布时，有必要知道客户预期的大致发布日期和故事的相对优先级。</li><li>故事应该以明确的顺序排列（第一个、第二个、第三个，等等），而不是利用诸如“非常高、高、中等”模糊顺序的分组。</li><li>故事的优先级由客户确定，但也要考虑开发人员的想法。</li><li>使用速率将以理想日为单位的估算转换成日历日。</li><li>估算团队的初始速率是很有必要的。</li></ul><h3 id="开发人员职责-6" tabindex="-1"><a class="header-anchor" href="#开发人员职责-6"><span>开发人员职责</span></a></h3><ul><li>负责提供信息（有时包括基本假设和可能的替代方法）给客户，以帮助她排列故事优先级。</li><li>负责在基础性需求或者架构性需求与其他客户需求之间取得权衡，避免不切实际地提高基础性需求或架构性需求的优先级。</li><li>建立发布计划时，负责在实际估算的基础上，适当包括一定长短的时间用以项目缓冲。</li></ul><h3 id="客户职责-4" tabindex="-1"><a class="header-anchor" href="#客户职责-4"><span>客户职责</span></a></h3><ul><li>负责以自己对故事价值的估计来确切排列用户故事的优先级。把故事排列为高、中、低这三个优先级是不够的。</li><li>负责诚实地表达发布期限。如果在 7 月 15 日需要，请不要为了保险起见而告诉开发人员 6 月 15 号就需要。</li><li>负责理解理想日和日历日的不同。</li><li>在想对故事的不同组件排列不同的优先级时，负责分割故事。</li><li>负责了解为何不应该谴责或批评一位个人速率为 0.6 的程序员，只因为她的速率小于 1.0。</li></ul><h2 id="第-10-章-迭代计划" tabindex="-1"><a class="header-anchor" href="#第-10-章-迭代计划"><span>第 10 章 迭代计划</span></a></h2><h3 id="讨论故事" tabindex="-1"><a class="header-anchor" href="#讨论故事"><span>讨论故事</span></a></h3><p>客户从最高优先级的故事开始读给开发人员听，然后由开发人员提问，直到他们充分理解故事，能从故事中分解出任务。没有必要理解故事的所有细节，会使会议冗长低效。在计划会议后，开发人员仍能和客户一起理清故事的关键细节。</p><h3 id="分解任务" tabindex="-1"><a class="header-anchor" href="#分解任务"><span>分解任务</span></a></h3><p>通常实现故事的开发人员不止一个，因为开发人员在某些特定技术上的专业性，要么是因为工作划分是完成故事的最快途径。 故事是对用户或客户有价值的功能的描述，它们并不是开发人员的待办事项。分解有助于发现那些可能会被遗忘的任务。整个小组一起来划分任务，依靠的是所有人的集体智慧。 一个故事的任务分解实际是即时设计（just in time design）的一次短脉冲。这些脉冲的集合取代了瀑布过程的前期设计阶段。 尤其需要注意，任务中包含更新用户指南和帮助系统的任务。</p><h3 id="准则" tabindex="-1"><a class="header-anchor" href="#准则"><span>准则</span></a></h3><p>从故事分解任务时，使用以下准则</p><ul><li>如果故事的某个任务特别难于估算，就把那个任务从故事的其余任务中分离出来</li><li>倘若有些任务可以很容易安排给多名开发人员共同完成，就分割它们</li><li>若有必要让客户了解故事某一部分的完成情况，可以把那部分拿出来作为一个任务</li></ul><h3 id="承担职责" tabindex="-1"><a class="header-anchor" href="#承担职责"><span>承担职责</span></a></h3><p>确保完成任务是团队中每个人的职责。团队药又一种“同舟共济”的心态。 在整轮迭代中，负责监控自己剩余的工作，同时也要监控队友剩余的工作。如果很快就能完成自己的工作，就有责任帮助队友承担部分工作。 在迭代结束时，不应该有人说“我完成了我的工作，但是 Tom 还有一些任务没有完成”。</p><h3 id="估算并确认" tabindex="-1"><a class="header-anchor" href="#估算并确认"><span>估算并确认</span></a></h3><h3 id="小结-9" tabindex="-1"><a class="header-anchor" href="#小结-9"><span>小结</span></a></h3><ul><li>迭代计划是发布计划的进一步计划，但只在迭代即将开始时才开始做迭代计划。</li><li>迭代计划中，团队讨论每个故事，然后从故事中分解出任务。</li><li>任务的大小没有强制的范围（例如，3 到 5 小时）。相反，从故事中分解出任务，用来帮助估算或鼓励多个开发人员合作完成一个故事。</li><li>每个任务都有开发人员承担。</li><li>开发人员通过估计他们承担的任务，评估他们是否承诺过度。</li></ul><h3 id="开发人员职责-7" tabindex="-1"><a class="header-anchor" href="#开发人员职责-7"><span>开发人员职责</span></a></h3><ul><li>负责参加迭代计划会议。</li><li>负责帮助把所有故事划分成任务，而不只是自己想做的故事。</li><li>负责为认领的任务承担责任。</li><li>负责确保承担适当工作量的工作。</li><li>在整轮迭代中，负责监控自己剩余的工作，同时也要监控队友剩余的工作。如果很快就能完成自己的工作，久有责任帮助队友承担部分工作。</li></ul><h3 id="客户职责-5" tabindex="-1"><a class="header-anchor" href="#客户职责-5"><span>客户职责</span></a></h3><ul><li>负责对迭代中包含的故事排列优先级。</li><li>负责知道开发人员交付他们能提供的最大商业价值。这意味着，从发布计划设定之后，若有更高价值的故事，要负责调整优先级以交付最大的商业价值。</li><li>负责参加迭代计划会议。</li></ul><h2 id="第-11-章-测试并监控速率" tabindex="-1"><a class="header-anchor" href="#第-11-章-测试并监控速率"><span>第 11 章 测试并监控速率</span></a></h2><p>我们将项目分成一系列迭代来做发布计划，每轮迭代中安排一定故事点的任务。一轮迭代完成的故事点就是项目的速率。</p><h3 id="测量速率" tabindex="-1"><a class="header-anchor" href="#测量速率"><span>测量速率</span></a></h3><p>不能将部分完成的故事也计算在速率中。首先是没法计算故事已完成的百分比。其次不想使用像 43.8 这样带小数的值为速率引入错误的精度。第三没完成的故事通常并不能给用户或客户带来任何价值。 如果经常发现迭代结束时有太多尚未全部完成的故事（哪怕这些都是半点的故事），这可能是团队内部缺乏合作的一个信号。用集中全部力量完成一个故事的方法会提高团队的意识：大家一起先完成一些故事比所有故事都只完成一部分更有价值。</p><h3 id="计划速率和实际速率" tabindex="-1"><a class="header-anchor" href="#计划速率和实际速率"><span>计划速率和实际速率</span></a></h3><p>检测实际速率与计划速率的偏差，或者说保证合理的速率，是很重要的。 一个比较好的方法是为每轮迭代画出计划速率和实际速率。 另外一个监控进展的好方法就是迭代燃尽图。可更好地展现项目的整体进展。</p><h3 id="迭代燃尽图-burn-down-chart" tabindex="-1"><a class="header-anchor" href="#迭代燃尽图-burn-down-chart"><span>迭代燃尽图（Burn Down Chart）</span></a></h3><h3 id="迭代中的燃尽图" tabindex="-1"><a class="header-anchor" href="#迭代中的燃尽图"><span>迭代中的燃尽图</span></a></h3><p>每日燃尽图</p><h3 id="小结-10" tabindex="-1"><a class="header-anchor" href="#小结-10"><span>小结</span></a></h3><ul><li>计算速率时只考虑那些已完成的故事，即通过验收测试的故事。不要计算迭代中团队未全部完成的故事。</li><li>为每轮迭代计划和实际完成的故事点数画图是监测实际和计划速率区别的好方法。</li><li>不要在一两轮迭代后就忙着预测速率趋势。</li><li>完成一个任务或故事所花费的实际小时数对速率没有影响。</li><li>在大家都能看到的公共区域贴一些大而可见的图。</li><li>累计故事点图很有用，因为我们可以从中看出每轮迭代中完成的故事点。</li><li>迭代燃尽图展示了用晚餐的故事点表示的进度和剩余故事的改变。</li><li>每日燃尽图在迭代中十分有用，它展示了迭代中每天剩余的小时数。</li><li>设计及检测一个平均每个故事点出现的缺陷数目的图表可以帮助我们发现团队速率的提高是不是以牺牲质量为代价。</li></ul><h3 id="开发人员职责-8" tabindex="-1"><a class="header-anchor" href="#开发人员职责-8"><span>开发人员职责</span></a></h3><ul><li>尽量在完成一个故事后再去做下一个故事。我们更希望看到少量已完成的故事，而不是较多未完成的故事。</li><li>清除所做的任何决定对项目速率的影响。</li></ul><h3 id="客户职责-6" tabindex="-1"><a class="header-anchor" href="#客户职责-6"><span>客户职责</span></a></h3><ul><li>知道团队的速率。</li><li>知道实际速率和计划速率的差别和是否需要调整计划。</li><li>为发布添加或删除故事，以确保团队在种种限制条件下尽量多实现项目目标。</li></ul><h2 id="第-12-章-故事不是什么" tabindex="-1"><a class="header-anchor" href="#第-12-章-故事不是什么"><span>第 12 章 故事不是什么</span></a></h2><h3 id="用户故事不是-ieee-830" tabindex="-1"><a class="header-anchor" href="#用户故事不是-ieee-830"><span>用户故事不是 IEEE 830</span></a></h3><p>用户看到正在开发的软件时，会有有效和重要的反馈循环。 IEEE 830 样式的需求侧重于关注需求的检查清单，而不是用户的目标。需求清单不会像故事那样给读者一个对产品的整体理解。读需求列表时，你会情不自禁地去考虑解决方案。 在写下所有需求前，每个需求的成本是不可见的。当客户在她的项目愿望清单中放入一项条目时，她要了解它的成本。</p><p>需求列表更大的问题是，列表上的项目描述了软件的行为，而不是用户的行为或目标。</p><h3 id="用户故事不是用例" tabindex="-1"><a class="header-anchor" href="#用户故事不是用例"><span>用户故事不是用例</span></a></h3><p>故事与用例之间最明显的区别是它们的范围。两者的大小都以交付商业价值为目标，但故事的范围更小，因为我们对它们的大小有限制，以便用于安排工作。用例覆盖的范围几乎总比故事大。 用户故事和用例的不同还在于它们的完整性，故事对应于用例的主要成功场景，而故事测试对应于用例扩展。 用例和故事之间另一个更重要的区别是它们的寿命。只要产品在开发和维护，用例常常作为永久性的“工件”持续存在。另一方面，故事不会超过包含它们的迭代。虽然可以对故事卡存档，许多团队却采用一种简单的处理方式，即撕掉它们。 另外的区别是用例比较容易包括用户界面的细节。 用例和用户故事还有一个区别是，它们的目的不同。用例编写成客户和开发都可以接受的格式，如此大家都可以读懂并达成一致，其目的是记录客户和开发团队之间的协议。而编写用户故事是为了更方便发布计划和迭代计划，并且它充当着用户具体需求对话的占位符。</p><h3 id="用户故事不是场景" tabindex="-1"><a class="header-anchor" href="#用户故事不是场景"><span>用户故事不是场景</span></a></h3><p>交互设计场景 - interaction design scenario</p><h3 id="小结-11" tabindex="-1"><a class="header-anchor" href="#小结-11"><span>小结</span></a></h3><ul><li>用户故事有别于 IEEE830 软件需求规格、用例和交互设计场景。</li><li>不管预想得多么全面，我们都无法事先完全定义一个完整的具有相当规模的系统。</li><li>在定义需求和用户早期频繁接触软件之间，有一个有价值的反馈循环。</li><li>考虑用户的目标比例出方案的特性更重要。</li><li>用户故事与用例场景类似。但用例往往仍然比单个故事要大，更容易包含关于用户界面的嵌入式假设。</li><li>此外，用户故事与用例的完整度和寿命不同。用例比用户故事完整得多。用例存在于整个开发过程中。用户故事往往只是暂时的，它们的生命周期仅仅限于开发它们的迭代中。</li><li>用户故事和用例以不同的目的编写。用例被编写成方便开发人员和客户讨论并达成共识。用户故事编写成方便计划发布，并用户提醒需求细节的讨论。</li><li>不像 IEEE830 规格和用例，用户故事不是分析活动的产物。相反，用户故事是进行分析的支持工具。</li><li>交互式设计场景比用户故事具体得多，它们提供的细节类型也不同。</li><li>典型的交互式设计场景比用户故事大得多。一个场景可以由多个用例组成，相应地，它可以组成许多用户故事。</li></ul><h2 id="第-13-章-用户故事的优势" tabindex="-1"><a class="header-anchor" href="#第-13-章-用户故事的优势"><span>第 13 章 用户故事的优势</span></a></h2><h3 id="口头沟通" tabindex="-1"><a class="header-anchor" href="#口头沟通"><span>口头沟通</span></a></h3><p>我们开始只关注一份共享的文档，而不是共有的认识。 就算需求文档里的每一句话都能够实现完美，还是存在两个问题。首先，随着软件的开发进程，用户会进一步了解软件，从而精炼他们的观点。其次，完美的部件并不能保证一定能带来完美的整体。相较于追求完美的需求，更有价值的是运用频繁的沟通来加强恰当的故事。</p><h3 id="用户故事容易理解" tabindex="-1"><a class="header-anchor" href="#用户故事容易理解"><span>用户故事容易理解</span></a></h3><h3 id="用户故事的大小适合做计划" tabindex="-1"><a class="header-anchor" href="#用户故事的大小适合做计划"><span>用户故事的大小适合做计划</span></a></h3><h3 id="用户故事适合于迭代开发" tabindex="-1"><a class="header-anchor" href="#用户故事适合于迭代开发"><span>用户故事适合于迭代开发</span></a></h3><h3 id="用户故事鼓励延迟细节" tabindex="-1"><a class="header-anchor" href="#用户故事鼓励延迟细节"><span>用户故事鼓励延迟细节</span></a></h3><p>用户故事非常适用于有时间限制的项目。团队可以非常迅速地写出数十个用户故事，让大家对要开发的系统有一个整体的概念，然后就能讨论前几个故事的细节并且开始编码。</p><h3 id="用户故事支持随机应变的开发" tabindex="-1"><a class="header-anchor" href="#用户故事支持随机应变的开发"><span>用户故事支持随机应变的开发</span></a></h3><p>为什么无法写下一个系统的所有需求：</p><ul><li>用户及客户通常都不会准确地知道自己的实际需求。</li><li>即便软件开发者知道所有的需求，很多需求细节只能随着他们的开发进展变得清晰。</li><li>就算假设所有的细节可以在前面弄清楚，人们也没有能力理解这么多的细节。</li><li>就算我们真的能理解所有的细节，产品和项目也会经常变更。</li><li>人非圣贤，孰能无过。</li></ul><h3 id="用户故事鼓励参与性设计" tabindex="-1"><a class="header-anchor" href="#用户故事鼓励参与性设计"><span>用户故事鼓励参与性设计</span></a></h3><h3 id="用户故事传播隐性知识" tabindex="-1"><a class="header-anchor" href="#用户故事传播隐性知识"><span>用户故事传播隐性知识</span></a></h3><p>缘于对面对面沟通的重视，故事能够促进团队内隐性知识的积累。</p><h3 id="用户故事的不足" tabindex="-1"><a class="header-anchor" href="#用户故事的不足"><span>用户故事的不足</span></a></h3><ul><li>拥有大量用户故事的大型项目中，故事之间的关系可能错综复杂，难以捉摸。</li><li>如果开发过程规定要有需求的可追溯性，必然离不开额外的文档。 在每一轮迭代开始时，生产一份文档，在其中列出该迭代中计划开发的每一个故事。随着测试的不断出现，我们把测试的名称添加到该文档中。在迭代进行期间，挪入或挪出故事时保持文档的更新。</li><li>虽然故事在一个团队内部能大大促进隐性知识的积累，但还是不适用于特大规模多团队的结构。这时，确实需要把有些交流记录下来，不然难以保证信息在大型团队中充分共享。当然，我们要在两种情况间取得平衡：很多人都知道一点点信息（通过低带宽的书面文档）；或者一小群人知道非常多信息（通过高带宽的面对面交流）。</li></ul><h3 id="小结-12" tabindex="-1"><a class="header-anchor" href="#小结-12"><span>小结</span></a></h3><ul><li>用户故事促使我们重视口头交流。与其他完全依赖书面文档的需求方法不同，用户故事认为开发人员与用户之间的交谈有重大的意义。</li><li>重视口头交流这一转变提供了迅速的反馈周期，往往能促成对需求的充分理解。</li><li>开发者与用户都能理解用户故事。IEEE830 软件需求规格往往容易充斥着太多的技术或商业术语。</li><li>用户故事的典型范围规模比用例及场景小，但比 IEEE830 文档大，这个大小适合于做计划。计划、编码及测试，都可以不再需要合并或分解故事就能完成。</li><li>用户故事适合于迭代开发，我们很容易从一个史诗故事入手。并在后来需要时把它分成多个小故事。</li><li>用户故事鼓励延迟细节。可以很快地写出独立的用户故事，而且写出不同大小的故事也很容易。对于不太重要的或者以开始不会被开发的需求，我们可以选择先用史诗故事来代表，而其他故事包含有更多的细节。</li><li>故事鼓励随机应变的开发。在此方式中，随着不断地发现机会，团队视线能迅速地在高层及低层细节思考间来回切换。</li><li>故事提升团队内隐性知识的水平。</li><li>用户故事鼓励参与性设计。与经验性设计不同，用户成为软件行为设计的活跃参与者，做出有价值的贡献。</li><li>虽然使用故事有不少的好处，不可否认也有一些缺点：大型项目中难以组织好成千上万的用户故事；有时候需要额外的文档以实现可追溯性；尽管面对面的沟通大大促进隐性知识的共享，但在大型项目中，单单依赖这种交谈难于实现有效的扩展来完全替代书面文档。</li></ul><h3 id="开发人员职责-9" tabindex="-1"><a class="header-anchor" href="#开发人员职责-9"><span>开发人员职责</span></a></h3><ul><li>理解选择任何方法的原因。如果团队决定使用用户故事，需要明白为什么。</li><li>了解其他需求方法的优点以及知道什么情况下适合使用。例如，如果有客户无法理解一个特性，可能需要与其讨论交互设计场景或者开发一个用例。</li></ul><h3 id="客户职责-7" tabindex="-1"><a class="header-anchor" href="#客户职责-7"><span>客户职责</span></a></h3><ul><li>用户故事与其他需求管理方式相比的一大优点是其鼓励参与性设计。应该积极参与软件的设计。</li></ul><h2 id="第-14-章-用户故事不良症兆一览" tabindex="-1"><a class="header-anchor" href="#第-14-章-用户故事不良症兆一览"><span>第 14 章 用户故事不良症兆一览</span></a></h2><h3 id="故事太小" tabindex="-1"><a class="header-anchor" href="#故事太小"><span>故事太小</span></a></h3><p>症状：经常需要调整估算</p><p>讨论：小故事的规模估算十分依赖于故事实现的顺序。实现顺序不同，规模估算值可能也有很大的差异，从而导致故事估算和计划出现问题。只要没有必要，不要划分组合故事。</p><h3 id="故事互相依赖" tabindex="-1"><a class="header-anchor" href="#故事互相依赖"><span>故事互相依赖</span></a></h3><p>症状：由于故事之间有依赖，所以很难做迭代计划。</p><p>讨论：如果觉得故事过小，就把互相依赖的故事合并成一个故事。如果故事规模刚刚好，就需要看一下故事划分是否恰当。</p><h3 id="镀金" tabindex="-1"><a class="header-anchor" href="#镀金"><span>镀金</span></a></h3><p>症状：开发人员在迭代中实现了计划外的功能，或者仅仅凭借自己的感觉实现故事，实现的功能超出了实际的需要。</p><p>讨论：“宠物功能”-客户并没有要求，但开发人员觉得炫的功能。 提高项目组中每个人的任务可见性，团队自我约束，减少镀金。在迭代结束时的演示会议中，也能发现哪些是镀金功能，尽管看起来比较晚，功能已经实现，但是可以让团队更意识到镀金的问题，从而避免以后再次发生。测试团队也可以帮助发现镀金问题。</p><h3 id="细节太多" tabindex="-1"><a class="header-anchor" href="#细节太多"><span>细节太多</span></a></h3><p>症状：在实现故事之前花太多的功夫去收集整理故事细节。也有可能是花太多的时间去写故事而不去讨论故事。</p><p>讨论：把故事写到小卡片商的一个好处是在小卡片上只能记录下很有限的东西。如果故事中包括太多的细节，说明团队过于重视文档，而忽视了口头交流。“如果总时需要写满小卡片，那下一次就用一个更小一点儿的卡片。”，迫使故事作者有意识地减少记录过多的故事细节。</p><h3 id="过早考虑用户界面细节" tabindex="-1"><a class="header-anchor" href="#过早考虑用户界面细节"><span>过早考虑用户界面细节</span></a></h3><p>症状：在项目（尤其是开发新产品）早期阶段编写的故事就已经包含用户界面细节。 讨论：只要有可能，尽量避免写包含具体信息的故事。</p><h3 id="想得太远" tabindex="-1"><a class="header-anchor" href="#想得太远"><span>想得太远</span></a></h3><p>症状：有几种表现形式。例如，小卡片空间小得难以记录用户故事的全部，又例如不是出于团队规模或者地域的考虑，希望用软件而不是小卡片来记录故事，又或者是某人建议用一个故事模板来捕捉故事相关的所有细节，又或者是建议用更精确的方法来估算（例如，用小时而不是用天为单位）</p><p>讨论：存在于喜欢在项目前期花很多功夫整理需求的团队。利用用户故事的关键在于承认事先不可能发现所有需求。好的软件是在不断的迭代中发展而来，而在每轮迭代中都会发现新的细节需求，然后被添加到软件中。用户故事与这种开发模式十分契合，就是因为我们可以不费力气地在未来的故事版本里添加细节。团队应该意识到采用用户故事的原因正是由于我们原来开发过程中存在着种种问题。</p><h3 id="故事划分太过频繁" tabindex="-1"><a class="header-anchor" href="#故事划分太过频繁"><span>故事划分太过频繁</span></a></h3><p>症状：在做迭代计划的时候为了确保迭代工作量合适，频繁地划分用户故事。</p><p>讨论：出现下列情况时需要划分故事，故事太大以至于不能在一轮迭代中完成；故事包括高优先级和低优先级的子故事，客户只希望在下轮迭代中完成高优先级的子故事。</p><h3 id="客户很难为故事安排优先级" tabindex="-1"><a class="header-anchor" href="#客户很难为故事安排优先级"><span>客户很难为故事安排优先级</span></a></h3><p>症状：安排优先级太困难。</p><p>讨论：可能时故事太大；故事体现不出商业价值。</p><h3 id="客户不愿意写用户故事-也不愿意为故事安排优先级" tabindex="-1"><a class="header-anchor" href="#客户不愿意写用户故事-也不愿意为故事安排优先级"><span>客户不愿意写用户故事，也不愿意为故事安排优先级</span></a></h3><p>症状：项目的客户不愿意承担写用户故事和安排优先级的责任。</p><p>讨论：互相指责的文化氛围</p><h2 id="第-15-章-scrum-与用户故事" tabindex="-1"><a class="header-anchor" href="#第-15-章-scrum-与用户故事"><span>第 15 章 Scrum 与用户故事</span></a></h2><h3 id="scrum-是迭代和递增的" tabindex="-1"><a class="header-anchor" href="#scrum-是迭代和递增的"><span>Scrum 是迭代和递增的</span></a></h3><p>一轮迭代的过程是一种持续改进的过程。一个比较好的类比是雕刻。</p><h3 id="scrum-基础" tabindex="-1"><a class="header-anchor" href="#scrum-基础"><span>Scrum 基础</span></a></h3><p>Sprint，Backlog</p><h3 id="scrum-团队" tabindex="-1"><a class="header-anchor" href="#scrum-团队"><span>Scrum 团队</span></a></h3><p>通常 4-7 个开发人员组成。整个团队总是同舟共济。大家共同负责结果。Scrum 团队往往是自组织的。 产品负责人和 ScrumMaster。产品负责人主要管理 Product Backlog 的内容以及排列优先级。ScrumMaster 的职能类似于项目经理，不过不是管理者的角色，更像一个领导者，主要负责为团队排除障碍，保证开发的顺利进行，确保整个团队按照 Scrum 的简单规则进行开发。</p><h3 id="产品-backlog" tabindex="-1"><a class="header-anchor" href="#产品-backlog"><span>产品 Backlog</span></a></h3><p>Backlog 是所有待开发产品功能的列表。</p><h3 id="sprint-计划会议" tabindex="-1"><a class="header-anchor" href="#sprint-计划会议"><span>Sprint 计划会议</span></a></h3><p>通常持续一整天，会议的参加者包括产品负责人、ScrumMaster 和团队的所有开发人员。如果又兴趣，其他的管理人员和客户代表也可以参加。 在 Sprint 计划会议的前半段，产品负责人会把待开发的高优先级的功能介绍给 Scrum 团队。在第二个阶段，团队成员可以针对第一阶段中介绍的每一个待开发功能提出问题，如果团队有信息完成某一个功能，就把这个功能从产品 Backlog 移到 Sprint Backlog。 根据产品 Backlog 中内容的多少和团队的速率，通常只需介绍产品 Backlog 中高优先级的条目，且不超过团队一个 Sprint 能够完成的总量。 团队和产品负责人一期确定整体的 Sprint 目标，Sprint 目标通常是关于下一个 Sprint 团队要完成工作的概述。在 Sprint 结束时的 Sprint 评审会议中，团队会审视自己是否达到了 Sprint 目标，而不是太关注于上个 Sprint 中完成的每一个具体条目。 在 Sprint 计划会议的下半段，团队会讨论这些用户故事，决定下一轮迭代能够完成的工作量。一般情况下，团队会和产品负责人沟通，但通常由团队决定一个 Sprint 能够完成多少。</p><h4 id="scrum-的主要规则" tabindex="-1"><a class="header-anchor" href="#scrum-的主要规则"><span>Scrum 的主要规则</span></a></h4><ul><li>在 Sprint 开始的时候召开 Sprint 计划会议。</li><li>每个 Sprint 必须发布可以工作的、经过测试的代码，这些代码能够完成对最终客户有价值的一些功能。</li><li>产品负责人为产品 Backlog 排列优先级。</li><li>团队一起决定一轮迭代完成多少故事。</li><li>在任何时候都可以向产品 Backlog 中添加故事，或者重新排列优先级。</li><li>每天有一个 Scrum 短会。么个项目成员回答三个问题：我昨天做了什么？我今天打算要做什么？我有什么困难？</li><li>只有团队成员能在每日 Scrum 简会中发言，其他人包括对项目感兴趣的观察者或者利益相关者都不能发言。</li><li>在 Sprint 结束时的 Sprint 评审会议中，团队会演示完成的成果。</li><li>团队演示的是可以工作的软件，而不是幻灯片。</li><li>准备 Sprint 评审会议的时间的超过两小时。</li></ul><p>在团队承诺完成 Sprint 计划会议中所选的全部工作的同时，组织也需要信守承诺不在 Sprint 期间改变 Sprint 的工作内容。如果有十分重要的事情发生，组织发现需要做出调整，就会把现在的 Sprint 取消，重新开 Sprint 计划会议，然后启动一个新的 Sprint。</p><h3 id="sprint-评审会议" tabindex="-1"><a class="header-anchor" href="#sprint-评审会议"><span>Sprint 评审会议</span></a></h3><p>每个 Sprint 都要发布一个“潜在可以交付的产品功能增量”。 在每个 Sprint 结束时，都会有一个 Sprint 评审会议。在会议上，团队会演示在 Sprint 中完成的工作，经常是新功能的演示。 有意保持 Sprint 评审会议的非正式会议性质，尽量不用幻灯片，准备时间也不要超过两个小时。不要让团队感觉 Sprint 评审会议是一种干扰或者负担，它应是 Sprint 自然而然的结果。 整个团队包括产品负责人和 ScrumMaster 都要参加 Sprint 评审会议。其他任何人（如管理层、客户和其他项目组的成员）如果感兴趣，也可以参加。</p><h3 id="每日-scrum-简会" tabindex="-1"><a class="header-anchor" href="#每日-scrum-简会"><span>每日 Scrum 简会</span></a></h3><p>Daily Scrum，很多敏捷过程包括极限编程和特征驱动开发（FDD-Feature Driven Development）都借鉴了这种做法。 每日 Scrum 简会安排得越早越好。所有人员（包括开发人员、测试人员、产品负责人和 ScrumMaster）都必须参加。 会议必须简短，一般在 15 分钟内结束，最多不超过 30 分钟。 不要演变成成员向 ScrumMaster 汇报工作的会议。这个会议的一个重要目的是让每个人在自己以及同事面前做出承诺。这个承诺不是向经理或者公司的承诺而是团队成员之间的承诺。 尽量只回答三个问题，不要演变成一个讨论系统设计或者解决问题的会议。一些问题会被记录下来稍后解决。有时候，团队的一部分成员需要留下来解决手头的问题，但注意，不要在每日短会中解决问题。 作为会议的组织者，ScrumMaster 需要保证会议的快节奏，产品负责人也需要向其他团队成员一样汇报进度。 每日例会的一个好处是它可以作为一个随机的检查点（checkpoint）。 如果团队以外的人员参加会议，需要遵守一个规则，即在会议中只有项目组内部人员才能够提问。其他人不能在会议上提任何问题，因为这样会干扰会议的顺利进行。 团队成员每天都能够了解到项目的进展。因此团队也可以重新审视目前任务分配的情况。 ScrumMaster 在会上必须要把握好尺度。需要保证会议的快节奏，同时也不要给大家一个感觉好像这个会议仅仅是为她一个人开的。有一个问题尤其不应该问“完成 xxx 还需要多长时间？”这个信息很重要，但是在会上问这个问题很容易让大家开始讨论估算和数字。</p><h3 id="在-scrum-中使用用户故事" tabindex="-1"><a class="header-anchor" href="#在-scrum-中使用用户故事"><span>在 Scrum 中使用用户故事</span></a></h3><h4 id="scrum-和产品-backlog" tabindex="-1"><a class="header-anchor" href="#scrum-和产品-backlog"><span>Scrum 和产品 Backlog</span></a></h4><p>在产品 Backlog 中的条目不再需要分为新功能、要调研的问题以及要解决的权限等，所有的条目都变成用户故事。产品 Backlog 中的每一个故事必须对客户或者产品负责人有价值。</p><h4 id="在-sprint-计划会议中使用用户故事" tabindex="-1"><a class="header-anchor" href="#在-sprint-计划会议中使用用户故事"><span>在 Sprint 计划会议中使用用户故事</span></a></h4><h4 id="在-sprint-评审会议中使用用户故事" tabindex="-1"><a class="header-anchor" href="#在-sprint-评审会议中使用用户故事"><span>在 Sprint 评审会议中使用用户故事</span></a></h4><h4 id="在每日-scrum-简会中使用用户故事" tabindex="-1"><a class="header-anchor" href="#在每日-scrum-简会中使用用户故事"><span>在每日 Scrum 简会中使用用户故事</span></a></h4><h3 id="小结-13" tabindex="-1"><a class="header-anchor" href="#小结-13"><span>小结</span></a></h3><ul><li>Scrum 是一种迭代和递增的过程。</li><li>Scrum 每 30 天一轮迭代，成为 Sprint。</li><li>ScrumMaster 相当于传统的项目经理，但更像领导者和组织者，而不是经理。</li><li>一般的 Scrum 团队包括 4-7 个开发人员。</li><li>产品 Backlog 是一个待开发的功能需求列表，里面的条目要么还没有实现到产品中，要么还没有计划在当前 Sprint 中开发。</li><li>Sprint Backlog 是一个团队承诺在当前 Sprint 完成的任务列表。</li><li>在极限编程里面的客户角色，在 Scrum 中成为产品负责人。</li><li>产品负责人负责给产品 Backlog 排列优先级。</li><li>在 Sprint 的开始，团队从产品 Backlog 中选择下一个 Sprint 要完成的任务。</li><li>每个 Sprint 都要完成一部分可以潜在交付的产品功能增量。</li><li>在 Sprint 结束时，团队在 Sprint 评审会议上演示所完成的功能。</li></ul><h2 id="第-16-章-其他话题" tabindex="-1"><a class="header-anchor" href="#第-16-章-其他话题"><span>第 16 章 其他话题</span></a></h2><h3 id="处理非功能性需求" tabindex="-1"><a class="header-anchor" href="#处理非功能性需求"><span>处理非功能性需求</span></a></h3><p>非功能性需求无法恰当地以用户故事的形式来表达。 常见的非功能性需求类型如下：</p><ul><li>性能（performance）</li><li>准确性（accuracy）</li><li>可移植性（portability）</li><li>可重用性（reusability）</li><li>可维护性（maintainability）</li><li>互操作性（interoperability）</li><li>可用性（availability）</li><li>易用性（usability）</li><li>安全性（security）</li><li>容量（capacity）</li></ul><p>许多非功能性的需求可以视为系统行为的约束。大多数情况下，编写自动化测试（并且至少每天运行一次）可以确保系统遵守约束。有一些约束无法进行实际测试或者不值得测试。可以用任何合适的或者传统的形式来沟通。</p><h3 id="纸质还是软件" tabindex="-1"><a class="header-anchor" href="#纸质还是软件"><span>纸质还是软件？</span></a></h3><p>极限编程重视简单的解决方案，纸质笔记卡绝对简单。此外，卡片可以鼓励交流和讨论。 卡片相对于软件工具的主要优点之一，时它们技术含量低的本质，可以不断提醒人们故事是不精确的。在软件中使用时，故事可能就要采用 IEEE830 样式需求的外观，由此，那些故事可能会增加额外的、不必要的细节。 推行 ISO（International Organization for Standardization，国际标准化组织）或类似认证的项目，需要从需求声明到代码以及测试的可追溯性，因此项目组很可能会喜欢使用软件。</p><h3 id="用户故事和用户界面" tabindex="-1"><a class="header-anchor" href="#用户故事和用户界面"><span>用户故事和用户界面</span></a></h3><p>用户故事允许延迟讨论，直到开发人员准备好实现故事。延迟讨论导致开发人员对现有应用程序的一部分进行轻微的返工是非常合乎情理的。这样不仅可以节省时间，不讨论那些未来可能会被抛弃的功能的需求，同时还使得客户可以通过许多小的阶段性修正来控制产品的发展方向。 基于故事的敏捷版以使用为中心的设计：</p><ul><li>用户角色建模</li><li>捕捞高层次的用户故事</li><li>排列故事优先级</li><li>精炼高优先级和中等优先级的故事</li><li>对故事整理分组</li><li>建立书面的原型</li><li>精炼该原型</li><li>开始编程</li></ul><h3 id="保留故事" tabindex="-1"><a class="header-anchor" href="#保留故事"><span>保留故事</span></a></h3><h3 id="缺陷的用户故事" tabindex="-1"><a class="header-anchor" href="#缺陷的用户故事"><span>缺陷的用户故事</span></a></h3><p>把小的缺陷报告用一个封面故事卡装订在一起，并把它们当成一个单一故事。</p><h3 id="开发人员职责-10" tabindex="-1"><a class="header-anchor" href="#开发人员职责-10"><span>开发人员职责</span></a></h3><ul><li>在适当的时候，建议并使用替代技术和方法来表示需求。</li><li>共同决定适用于项目的方式：笔记卡还是软件系统。</li><li>共同理解在项目开始时考虑所有用户界面的优点和缺点。</li></ul><h3 id="客户职责-8" tabindex="-1"><a class="header-anchor" href="#客户职责-8"><span>客户职责</span></a></h3><ul><li>如果觉得用户故事无法准确地反映需求的一部分，应该要求使用替代技术和方法来表示需求。</li><li>共同决定适用于项目的方式：笔记卡还是软件系统。</li><li>共同理解在项目开始时考虑所有用户界面的优点和缺点。</li></ul><h2 id="极限编程" tabindex="-1"><a class="header-anchor" href="#极限编程"><span>极限编程</span></a></h2><p>极限编程，Extreme Programming， 简称 XP。</p><h3 id="角色" tabindex="-1"><a class="header-anchor" href="#角色"><span>角色</span></a></h3><h3 id="_12-个实践" tabindex="-1"><a class="header-anchor" href="#_12-个实践"><span>12 个实践</span></a></h3><h4 id="短交付周期-small-releases" tabindex="-1"><a class="header-anchor" href="#短交付周期-small-releases"><span>短交付周期（small releases）</span></a></h4><p>用户故事所描述的功能，在单轮迭代里是完全可交付的。团队不允许交付未完成的功能。 团队应选择尽可能短的迭代长度，但要确保仍能够交付可见的商业价值。 迭代是固定的时间箱。团队不能在既定迭代的最后一天决定它们还需要两天。迭代在规定的日期结束。可以调整团队的工作量（但不是工作质量）以适应迭代。</p><h4 id="计划游戏-the-planning-game" tabindex="-1"><a class="header-anchor" href="#计划游戏-the-planning-game"><span>计划游戏（the planning game）</span></a></h4><p>在做计划时，开发人员和客户人员一起对未来做出预测。 发布计划不会准确反映哪些故事会被开发，以及它们以何种顺序开发。发布计划是关于开发如何进行的假设，在迭代开始、优先级改变，团队的进展速度更加明确，开发人员更加了解每个故事的实际预期成本后，可以更新发布计划。</p><h4 id="重构-refactoring" tabindex="-1"><a class="header-anchor" href="#重构-refactoring"><span>重构（refactoring）</span></a></h4><p>XP 主张不断关注重构。一旦有程序员更改代码，发现应该进行重构时，就必须重构它。不是鼓励她重构，而是她必须进行重构。这样可以避免代码中缓慢的但有时很难发现且最终导致代码被废弃的腐朽。 重构是 XP 用于取代前期设计的方法之一。不是先期花时间去思考系统，而是编码，因此要猜测其行为的某些方面，XP 系统不断重构，并确保很好地实现当前已知的需求。</p><h4 id="测试-testing" tabindex="-1"><a class="header-anchor" href="#测试-testing"><span>测试（testing）</span></a></h4><p>XP 重视测试。TDD 对每个故事，客户负责定义一系列测试，用来确定开发好的故事是否符合他们的期望和假设。在许多方面，这些客户编写的验收测试会取代瀑布过程的需求文档。</p><h4 id="结对编程-pare-programming" tabindex="-1"><a class="header-anchor" href="#结对编程-pare-programming"><span>结对编程（pare programming）</span></a></h4><ul><li>更少的缺陷</li><li>解决相同的问题编写的代码更少</li><li>解决问题更快</li><li>理解每一块代码的人更多</li><li>开发工作的满意度增加了</li></ul><h4 id="持续一直的速度-sustainable-pace" tabindex="-1"><a class="header-anchor" href="#持续一直的速度-sustainable-pace"><span>持续一直的速度（sustainable pace）</span></a></h4><p>XP 教练负责监视团队是否过度劳累。</p><h4 id="团队代码所有权-team-code-ownership" tabindex="-1"><a class="header-anchor" href="#团队代码所有权-team-code-ownership"><span>团队代码所有权（team code ownership）</span></a></h4><p>个人所有权用以确保一致的设计，并保持一个模块所有责任的平衡。在 XP 中，这个重担由测试驱动开发承担。一套健壮的单元测试可以确保修改不会引入以外的副作用。</p><h4 id="编码标准-coding-standard" tabindex="-1"><a class="header-anchor" href="#编码标准-coding-standard"><span>编码标准（coding standard）</span></a></h4><p>因为 XP 团队集体用用他们的源代码，所以遵循同一个编码标准很重要。</p><h4 id="简单设计-simple-design" tabindex="-1"><a class="header-anchor" href="#简单设计-simple-design"><span>简单设计（simple design）</span></a></h4><p>四个约束表明某种设计是最简单的</p><ul><li>业务代码和测试代码充分表达程序员的意图。</li><li>没有重复代码。</li><li>系统使用最少数量的类。</li><li>系统使用最少数量的方法。</li></ul><h4 id="隐喻-metaphor" tabindex="-1"><a class="header-anchor" href="#隐喻-metaphor"><span>隐喻（metaphor）</span></a></h4><p>隐喻提供一个如何思考系统的参照体系。提供一种方便、简单的方式来思考系统的行为。</p><h4 id="持续集成-continuous-integration" tabindex="-1"><a class="header-anchor" href="#持续集成-continuous-integration"><span>持续集成（continuous integration）</span></a></h4><p>每天至少做一次集成，触发自动化测试。出现集成问题时，每次往往只需要少量的修改就能够解决。</p><h4 id="现场客户-on-site-customer" tabindex="-1"><a class="header-anchor" href="#现场客户-on-site-customer"><span>现场客户（on-site customer）</span></a></h4><p>过去，客户编写好需求文档，把它扔给墙外编写代码的程序员，接着又把系统抛过墙给一些测试人员。使用 XP，这道墙不复存在，客户将和开发团队坐在一起，并成为团队的一部分。客户编写故事和验收测试，并当场尽快回答团队的问题。如果客户不在现场，延迟将打乱 XP 团队所预测的进度。</p><h3 id="极限编程的价值" tabindex="-1"><a class="header-anchor" href="#极限编程的价值"><span>极限编程的价值</span></a></h3><p>沟通（communication）、简单（simplicity）、反馈（feedback）和勇气（courage）。</p><h4 id="极限编程的原则" tabindex="-1"><a class="header-anchor" href="#极限编程的原则"><span>极限编程的原则</span></a></h4><p>快速反馈（rapid feedback）、假设简单（assuming simplicity）、增量变化（incremental change）、拥抱变化（embrace change）、高品质的产品（doing quality work）。</p>',323)]))}const t=a(h,[["render",s]]),p=JSON.parse('{"path":"/1.capacity/08.agile/book-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E4%B8%8E%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95.html","title":"用户故事与敏捷方法","lang":"zh-cn","frontmatter":{},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[{"level":3,"title":"使用用户故事，不仅仅是为了快","slug":"使用用户故事-不仅仅是为了快","link":"#使用用户故事-不仅仅是为了快","children":[]}]},{"level":2,"title":"第 1 章 概览","slug":"第-1-章-概览","link":"#第-1-章-概览","children":[{"level":3,"title":"什么是用户故事","slug":"什么是用户故事","link":"#什么是用户故事","children":[]},{"level":3,"title":"规划发布和迭代","slug":"规划发布和迭代","link":"#规划发布和迭代","children":[]},{"level":3,"title":"验收测试","slug":"验收测试","link":"#验收测试","children":[]},{"level":3,"title":"为什么要编写故事卡而不继续需求文档或者用例","slug":"为什么要编写故事卡而不继续需求文档或者用例","link":"#为什么要编写故事卡而不继续需求文档或者用例","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"第 2 章 编写故事","slug":"第-2-章-编写故事","link":"#第-2-章-编写故事","children":[{"level":3,"title":"用户故事六个特征","slug":"用户故事六个特征","link":"#用户故事六个特征","children":[]}]},{"level":2,"title":"第 3 章 用户角色建模","slug":"第-3-章-用户角色建模","link":"#第-3-章-用户角色建模","children":[{"level":3,"title":"用户角色","slug":"用户角色","link":"#用户角色","children":[]},{"level":3,"title":"角色建模的步骤","slug":"角色建模的步骤","link":"#角色建模的步骤","children":[]}]},{"level":2,"title":"第 4 章 搜集故事","slug":"第-4-章-搜集故事","link":"#第-4-章-搜集故事","children":[{"level":3,"title":"引出和捕捉是不合用的","slug":"引出和捕捉是不合用的","link":"#引出和捕捉是不合用的","children":[]},{"level":3,"title":"够用就行，不是吗","slug":"够用就行-不是吗","link":"#够用就行-不是吗","children":[]},{"level":3,"title":"方法","slug":"方法","link":"#方法","children":[]}]},{"level":2,"title":"第 5 章 与用户代理合作","slug":"第-5-章-与用户代理合作","link":"#第-5-章-与用户代理合作","children":[{"level":3,"title":"用户的经理","slug":"用户的经理","link":"#用户的经理","children":[]},{"level":3,"title":"开发经理","slug":"开发经理","link":"#开发经理","children":[]},{"level":3,"title":"销售人员","slug":"销售人员","link":"#销售人员","children":[]},{"level":3,"title":"领域专家","slug":"领域专家","link":"#领域专家","children":[]},{"level":3,"title":"市场营销团队","slug":"市场营销团队","link":"#市场营销团队","children":[]},{"level":3,"title":"以前的用户","slug":"以前的用户","link":"#以前的用户","children":[]},{"level":3,"title":"客户","slug":"客户","link":"#客户","children":[]},{"level":3,"title":"培训师和技术支持","slug":"培训师和技术支持","link":"#培训师和技术支持","children":[]},{"level":3,"title":"业务分析师或系统分析师","slug":"业务分析师或系统分析师","link":"#业务分析师或系统分析师","children":[]},{"level":3,"title":"与用户代理合作时，做些什么？","slug":"与用户代理合作时-做些什么","link":"#与用户代理合作时-做些什么","children":[]},{"level":3,"title":"设立客户团队","slug":"设立客户团队","link":"#设立客户团队","children":[]},{"level":3,"title":"小结","slug":"小结-4","link":"#小结-4","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-3","link":"#开发人员职责-3","children":[]},{"level":3,"title":"客户团队职责","slug":"客户团队职责-1","link":"#客户团队职责-1","children":[]}]},{"level":2,"title":"第 6 章 用户故事验收测试","slug":"第-6-章-用户故事验收测试","link":"#第-6-章-用户故事验收测试","children":[{"level":3,"title":"在写代码之前写测试","slug":"在写代码之前写测试","link":"#在写代码之前写测试","children":[]},{"level":3,"title":"客户定义测试","slug":"客户定义测试","link":"#客户定义测试","children":[]},{"level":3,"title":"测试是过程的一部分","slug":"测试是过程的一部分","link":"#测试是过程的一部分","children":[]},{"level":3,"title":"多少测试才算多？","slug":"多少测试才算多","link":"#多少测试才算多","children":[]},{"level":3,"title":"测试类型","slug":"测试类型","link":"#测试类型","children":[]},{"level":3,"title":"小结","slug":"小结-5","link":"#小结-5","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-4","link":"#开发人员职责-4","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-2","link":"#客户职责-2","children":[]}]},{"level":2,"title":"第 7 章 优秀用户故事准则","slug":"第-7-章-优秀用户故事准则","link":"#第-7-章-优秀用户故事准则","children":[{"level":3,"title":"从目标故事开始","slug":"从目标故事开始","link":"#从目标故事开始","children":[]},{"level":3,"title":"切蛋糕","slug":"切蛋糕","link":"#切蛋糕","children":[]},{"level":3,"title":"编写封闭的故事","slug":"编写封闭的故事","link":"#编写封闭的故事","children":[]},{"level":3,"title":"卡片约束","slug":"卡片约束","link":"#卡片约束","children":[]},{"level":3,"title":"根据实现时间来确定故事规模","slug":"根据实现时间来确定故事规模","link":"#根据实现时间来确定故事规模","children":[]},{"level":3,"title":"不要过早涉及用户界面","slug":"不要过早涉及用户界面","link":"#不要过早涉及用户界面","children":[]},{"level":3,"title":"有些需求并不是故事","slug":"有些需求并不是故事","link":"#有些需求并不是故事","children":[]},{"level":3,"title":"在故事里包括用户角色","slug":"在故事里包括用户角色","link":"#在故事里包括用户角色","children":[]},{"level":3,"title":"只为一个用户编写","slug":"只为一个用户编写","link":"#只为一个用户编写","children":[]},{"level":3,"title":"以主语动态编写","slug":"以主语动态编写","link":"#以主语动态编写","children":[]},{"level":3,"title":"由客户编写","slug":"由客户编写","link":"#由客户编写","children":[]},{"level":3,"title":"向故事卡编号说“不”","slug":"向故事卡编号说-不","link":"#向故事卡编号说-不","children":[]},{"level":3,"title":"不要忘记意图","slug":"不要忘记意图","link":"#不要忘记意图","children":[]},{"level":3,"title":"小结","slug":"小结-6","link":"#小结-6","children":[]}]},{"level":2,"title":"第 8 章 估算用户故事","slug":"第-8-章-估算用户故事","link":"#第-8-章-估算用户故事","children":[{"level":3,"title":"故事点（Story Point）","slug":"故事点-story-point","link":"#故事点-story-point","children":[]},{"level":3,"title":"以团队估算","slug":"以团队估算","link":"#以团队估算","children":[]},{"level":3,"title":"估算","slug":"估算","link":"#估算","children":[]},{"level":3,"title":"三角测量","slug":"三角测量","link":"#三角测量","children":[]},{"level":3,"title":"使用故事点","slug":"使用故事点","link":"#使用故事点","children":[]},{"level":3,"title":"小结","slug":"小结-7","link":"#小结-7","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-5","link":"#开发人员职责-5","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-3","link":"#客户职责-3","children":[]}]},{"level":2,"title":"第 9 章 发布计划","slug":"第-9-章-发布计划","link":"#第-9-章-发布计划","children":[{"level":3,"title":"我们想在什么时候发布","slug":"我们想在什么时候发布","link":"#我们想在什么时候发布","children":[]},{"level":3,"title":"希望在发布中包含哪些功能？","slug":"希望在发布中包含哪些功能","link":"#希望在发布中包含哪些功能","children":[]},{"level":3,"title":"排列故事的优先级","slug":"排列故事的优先级","link":"#排列故事的优先级","children":[]},{"level":3,"title":"混合优先级","slug":"混合优先级","link":"#混合优先级","children":[]},{"level":3,"title":"高风险故事","slug":"高风险故事","link":"#高风险故事","children":[]},{"level":3,"title":"根据架构需要安排优先级","slug":"根据架构需要安排优先级","link":"#根据架构需要安排优先级","children":[]},{"level":3,"title":"选择迭代长度","slug":"选择迭代长度","link":"#选择迭代长度","children":[]},{"level":3,"title":"从故事点到预计工期","slug":"从故事点到预计工期","link":"#从故事点到预计工期","children":[]},{"level":3,"title":"初始速率","slug":"初始速率","link":"#初始速率","children":[]},{"level":3,"title":"创建发布计划","slug":"创建发布计划","link":"#创建发布计划","children":[]},{"level":3,"title":"小结","slug":"小结-8","link":"#小结-8","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-6","link":"#开发人员职责-6","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-4","link":"#客户职责-4","children":[]}]},{"level":2,"title":"第 10 章 迭代计划","slug":"第-10-章-迭代计划","link":"#第-10-章-迭代计划","children":[{"level":3,"title":"讨论故事","slug":"讨论故事","link":"#讨论故事","children":[]},{"level":3,"title":"分解任务","slug":"分解任务","link":"#分解任务","children":[]},{"level":3,"title":"准则","slug":"准则","link":"#准则","children":[]},{"level":3,"title":"承担职责","slug":"承担职责","link":"#承担职责","children":[]},{"level":3,"title":"估算并确认","slug":"估算并确认","link":"#估算并确认","children":[]},{"level":3,"title":"小结","slug":"小结-9","link":"#小结-9","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-7","link":"#开发人员职责-7","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-5","link":"#客户职责-5","children":[]}]},{"level":2,"title":"第 11 章 测试并监控速率","slug":"第-11-章-测试并监控速率","link":"#第-11-章-测试并监控速率","children":[{"level":3,"title":"测量速率","slug":"测量速率","link":"#测量速率","children":[]},{"level":3,"title":"计划速率和实际速率","slug":"计划速率和实际速率","link":"#计划速率和实际速率","children":[]},{"level":3,"title":"迭代燃尽图（Burn Down Chart）","slug":"迭代燃尽图-burn-down-chart","link":"#迭代燃尽图-burn-down-chart","children":[]},{"level":3,"title":"迭代中的燃尽图","slug":"迭代中的燃尽图","link":"#迭代中的燃尽图","children":[]},{"level":3,"title":"小结","slug":"小结-10","link":"#小结-10","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-8","link":"#开发人员职责-8","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-6","link":"#客户职责-6","children":[]}]},{"level":2,"title":"第 12 章 故事不是什么","slug":"第-12-章-故事不是什么","link":"#第-12-章-故事不是什么","children":[{"level":3,"title":"用户故事不是 IEEE 830","slug":"用户故事不是-ieee-830","link":"#用户故事不是-ieee-830","children":[]},{"level":3,"title":"用户故事不是用例","slug":"用户故事不是用例","link":"#用户故事不是用例","children":[]},{"level":3,"title":"用户故事不是场景","slug":"用户故事不是场景","link":"#用户故事不是场景","children":[]},{"level":3,"title":"小结","slug":"小结-11","link":"#小结-11","children":[]}]},{"level":2,"title":"第 13 章 用户故事的优势","slug":"第-13-章-用户故事的优势","link":"#第-13-章-用户故事的优势","children":[{"level":3,"title":"口头沟通","slug":"口头沟通","link":"#口头沟通","children":[]},{"level":3,"title":"用户故事容易理解","slug":"用户故事容易理解","link":"#用户故事容易理解","children":[]},{"level":3,"title":"用户故事的大小适合做计划","slug":"用户故事的大小适合做计划","link":"#用户故事的大小适合做计划","children":[]},{"level":3,"title":"用户故事适合于迭代开发","slug":"用户故事适合于迭代开发","link":"#用户故事适合于迭代开发","children":[]},{"level":3,"title":"用户故事鼓励延迟细节","slug":"用户故事鼓励延迟细节","link":"#用户故事鼓励延迟细节","children":[]},{"level":3,"title":"用户故事支持随机应变的开发","slug":"用户故事支持随机应变的开发","link":"#用户故事支持随机应变的开发","children":[]},{"level":3,"title":"用户故事鼓励参与性设计","slug":"用户故事鼓励参与性设计","link":"#用户故事鼓励参与性设计","children":[]},{"level":3,"title":"用户故事传播隐性知识","slug":"用户故事传播隐性知识","link":"#用户故事传播隐性知识","children":[]},{"level":3,"title":"用户故事的不足","slug":"用户故事的不足","link":"#用户故事的不足","children":[]},{"level":3,"title":"小结","slug":"小结-12","link":"#小结-12","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-9","link":"#开发人员职责-9","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-7","link":"#客户职责-7","children":[]}]},{"level":2,"title":"第 14 章 用户故事不良症兆一览","slug":"第-14-章-用户故事不良症兆一览","link":"#第-14-章-用户故事不良症兆一览","children":[{"level":3,"title":"故事太小","slug":"故事太小","link":"#故事太小","children":[]},{"level":3,"title":"故事互相依赖","slug":"故事互相依赖","link":"#故事互相依赖","children":[]},{"level":3,"title":"镀金","slug":"镀金","link":"#镀金","children":[]},{"level":3,"title":"细节太多","slug":"细节太多","link":"#细节太多","children":[]},{"level":3,"title":"过早考虑用户界面细节","slug":"过早考虑用户界面细节","link":"#过早考虑用户界面细节","children":[]},{"level":3,"title":"想得太远","slug":"想得太远","link":"#想得太远","children":[]},{"level":3,"title":"故事划分太过频繁","slug":"故事划分太过频繁","link":"#故事划分太过频繁","children":[]},{"level":3,"title":"客户很难为故事安排优先级","slug":"客户很难为故事安排优先级","link":"#客户很难为故事安排优先级","children":[]},{"level":3,"title":"客户不愿意写用户故事，也不愿意为故事安排优先级","slug":"客户不愿意写用户故事-也不愿意为故事安排优先级","link":"#客户不愿意写用户故事-也不愿意为故事安排优先级","children":[]}]},{"level":2,"title":"第 15 章 Scrum 与用户故事","slug":"第-15-章-scrum-与用户故事","link":"#第-15-章-scrum-与用户故事","children":[{"level":3,"title":"Scrum 是迭代和递增的","slug":"scrum-是迭代和递增的","link":"#scrum-是迭代和递增的","children":[]},{"level":3,"title":"Scrum 基础","slug":"scrum-基础","link":"#scrum-基础","children":[]},{"level":3,"title":"Scrum 团队","slug":"scrum-团队","link":"#scrum-团队","children":[]},{"level":3,"title":"产品 Backlog","slug":"产品-backlog","link":"#产品-backlog","children":[]},{"level":3,"title":"Sprint 计划会议","slug":"sprint-计划会议","link":"#sprint-计划会议","children":[]},{"level":3,"title":"Sprint 评审会议","slug":"sprint-评审会议","link":"#sprint-评审会议","children":[]},{"level":3,"title":"每日 Scrum 简会","slug":"每日-scrum-简会","link":"#每日-scrum-简会","children":[]},{"level":3,"title":"在 Scrum 中使用用户故事","slug":"在-scrum-中使用用户故事","link":"#在-scrum-中使用用户故事","children":[]},{"level":3,"title":"小结","slug":"小结-13","link":"#小结-13","children":[]}]},{"level":2,"title":"第 16 章 其他话题","slug":"第-16-章-其他话题","link":"#第-16-章-其他话题","children":[{"level":3,"title":"处理非功能性需求","slug":"处理非功能性需求","link":"#处理非功能性需求","children":[]},{"level":3,"title":"纸质还是软件？","slug":"纸质还是软件","link":"#纸质还是软件","children":[]},{"level":3,"title":"用户故事和用户界面","slug":"用户故事和用户界面","link":"#用户故事和用户界面","children":[]},{"level":3,"title":"保留故事","slug":"保留故事","link":"#保留故事","children":[]},{"level":3,"title":"缺陷的用户故事","slug":"缺陷的用户故事","link":"#缺陷的用户故事","children":[]},{"level":3,"title":"开发人员职责","slug":"开发人员职责-10","link":"#开发人员职责-10","children":[]},{"level":3,"title":"客户职责","slug":"客户职责-8","link":"#客户职责-8","children":[]}]},{"level":2,"title":"极限编程","slug":"极限编程","link":"#极限编程","children":[{"level":3,"title":"角色","slug":"角色","link":"#角色","children":[]},{"level":3,"title":"12 个实践","slug":"_12-个实践","link":"#_12-个实践","children":[]},{"level":3,"title":"极限编程的价值","slug":"极限编程的价值","link":"#极限编程的价值","children":[]}]}],"git":{"updatedTime":1745032055000,"contributors":[{"name":"guoxin-qiu","username":"guoxin-qiu","email":"guoxin.qiu@outlook.com","commits":6,"url":"https://github.com/guoxin-qiu"}],"changelog":[{"hash":"a2b6e78156eb7f1fed6ecb0952cc98c6b90aa9d3","time":1745032055000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"change hierarchy"},{"hash":"cf1a535ce24165a7f8da8bf85c1c9f2de88d6068","time":1692634731000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: change the groups"},{"hash":"bc5fc84fdf6fd884abb955e1a988e9c3efc27906","time":1683359805000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: 用户故事与敏捷方法 完结"},{"hash":"68170952655610abba957ba6ee309b12144937f9","time":1682504583000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: on 20230426"},{"hash":"24795fa27668d9eb86a60f67b09182b15314e9bc","time":1682330132000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"chore: structure adjust big big"},{"hash":"1b4766cde36ab7fa10905d1182e7dac1cf4753fc","time":1671036194000,"email":"guoxin.qiu@outlook.com","author":"guoxin-qiu","message":"update: add something"}]},"filePathRelative":"1.capacity/08.agile/book-用户故事与敏捷方法.md"}');export{t as comp,p as data};
